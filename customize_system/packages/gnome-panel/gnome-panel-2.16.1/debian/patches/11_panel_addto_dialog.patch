diff -Nur gnome-panel-2.16.1/gnome-panel/Makefile.am gnome-panel-2.16.1.new/gnome-panel/Makefile.am
--- gnome-panel-2.16.1/gnome-panel/Makefile.am	2006-08-07 23:07:46.000000000 +0200
+++ gnome-panel-2.16.1.new/gnome-panel/Makefile.am	2006-10-03 01:10:39.000000000 +0200
@@ -95,6 +95,9 @@
 	panel-force-quit.c	\
 	panel-lockdown.c	\
 	panel-addto.c		\
+	panel-addto-canvas.c    \
+	panel-addto-rounded-rect.c \
+	panel-addto-event-box.c \
 	panel-logout.c		\
 	panel-gdm.c		\
 	panel-power-manager.c   \
@@ -144,6 +147,10 @@
 	panel-force-quit.h	\
 	panel-lockdown.h	\
 	panel-addto.h		\
+	panel-addto-canvas.h    \
+	panel-addto-rounded-rect.h \
+	panel-addto-rounded-rect-pixbuf.h \
+	panel-addto-event-box.h \
 	panel-logout.h		\
 	panel-gdm.h		\
 	panel-power-manager.h	\
diff -Nur gnome-panel-2.16.1/gnome-panel/panel-action-button.c gnome-panel-2.16.1.new/gnome-panel/panel-action-button.c
--- gnome-panel-2.16.1/gnome-panel/panel-action-button.c	2006-10-03 01:10:38.000000000 +0200
+++ gnome-panel-2.16.1.new/gnome-panel/panel-action-button.c	2006-10-03 01:10:39.000000000 +0200
@@ -252,6 +252,8 @@
 	PanelActionButtonType   type;
 	char                   *icon_name;
 	char                   *text;
+	char                   *category;
+	char                   *english_category;
 	char                   *tooltip;
 	char                   *help_index;
 	char                   *drag_id;
@@ -274,6 +276,8 @@
 		PANEL_ACTION_LOCK,
 		"gnome-lockscreen",
 		N_("Lock Screen"),
+		N_("Desktop &amp; Windows"),
+		"Desktop &amp; Windows",
 		N_("Protect your computer from unauthorized use"),
 		"gospanel-21",
 		"ACTION:lock:NEW",
@@ -289,6 +293,8 @@
 		 * update the ones in panel-menu-items.c (look for
 		 * panel:showusername|1) */
 		N_("Quit..."),
+		N_("Desktop &amp; Windows"),
+		"Desktop &amp; Windows",
 		N_("Log off, switch user, lock screen or power down the computer"),
 		"gospanel-20",
 		"ACTION:logout:NEW",
@@ -299,6 +305,8 @@
 		PANEL_ACTION_RUN,
 		PANEL_RUN_ICON,
 		N_("Run Application..."),
+		N_("Utilities"),
+		"Utilities",
 		N_("Run an Application by entering a command"),
 		"gospanel-555",
 		"ACTION:run:NEW",
@@ -309,6 +317,8 @@
 		PANEL_ACTION_SEARCH,
 		"gnome-searchtool",
 		N_("Search for Files..."),
+		N_("Utilities"),
+		"Utilities",
 		N_("Find files, folders, and documents on your computer"),
 		"gospanel-554",
 		"ACTION:search:NEW",
@@ -318,6 +328,8 @@
 		PANEL_ACTION_FORCE_QUIT,
 		PANEL_FORCE_QUIT_ICON,
 		N_("Force Quit"),
+		N_("Desktop &amp; Windows"),
+		"Desktop &amp; Windows",
 		N_("Force a misbehaving application to quit"),
 		"gospanel-563",
 		"ACTION:force-quit:NEW",
@@ -328,6 +340,8 @@
 		PANEL_ACTION_CONNECT_SERVER,
 		"gnome-globe", //FIXME icon
 		N_("Connect to Server..."),
+		N_("Utilities"),
+		"Utilities",
 		N_("Connect to a remote server"), //FIXME
 		"gospanel-563", //FIXME
 		"ACTION:connect-server:NEW",
@@ -337,6 +351,8 @@
 		PANEL_ACTION_SHUTDOWN,
 		"gnome-shutdown",
 		N_("Shut Down..."),
+                N_("Utilities"),
+                "Utilities",
 		N_("Shut down the computer"),
 		"gospanel-20",
 		"ACTION:shutdown:NEW",
@@ -400,6 +416,22 @@
 }
 
 G_CONST_RETURN char*
+panel_action_get_category (PanelActionButtonType type)
+{
+	g_return_val_if_fail (type > PANEL_ACTION_NONE && type < PANEL_ACTION_LAST, NULL);
+
+	return _(actions[type].category);
+}
+
+G_CONST_RETURN char*
+panel_action_get_english_category (PanelActionButtonType type)
+{
+	g_return_val_if_fail (type > PANEL_ACTION_NONE && type < PANEL_ACTION_LAST, NULL);
+
+	return actions[type].english_category;
+}
+
+G_CONST_RETURN char*
 panel_action_get_tooltip (PanelActionButtonType type)
 {
 	g_return_val_if_fail (type > PANEL_ACTION_NONE && type < PANEL_ACTION_LAST, NULL);
diff -Nur gnome-panel-2.16.1/gnome-panel/panel-action-button.h gnome-panel-2.16.1.new/gnome-panel/panel-action-button.h
--- gnome-panel-2.16.1/gnome-panel/panel-action-button.h	2005-01-29 21:39:01.000000000 +0100
+++ gnome-panel-2.16.1.new/gnome-panel/panel-action-button.h	2006-10-03 01:10:39.000000000 +0200
@@ -87,12 +87,14 @@
 						 const char             *drag_string,
 						 int                    *old_applet_idx);
 
-gboolean             panel_action_get_is_disabled (PanelActionButtonType type);
-GCallback            panel_action_get_invoke      (PanelActionButtonType type);
-G_CONST_RETURN char *panel_action_get_icon_name   (PanelActionButtonType type);
-G_CONST_RETURN char *panel_action_get_text        (PanelActionButtonType type);
-G_CONST_RETURN char *panel_action_get_tooltip     (PanelActionButtonType type);
-G_CONST_RETURN char *panel_action_get_drag_id     (PanelActionButtonType type);
+gboolean             panel_action_get_is_disabled      (PanelActionButtonType type);
+GCallback            panel_action_get_invoke           (PanelActionButtonType type);
+G_CONST_RETURN char *panel_action_get_icon_name        (PanelActionButtonType type);
+G_CONST_RETURN char *panel_action_get_text             (PanelActionButtonType type);
+G_CONST_RETURN char *panel_action_get_category         (PanelActionButtonType type);
+G_CONST_RETURN char *panel_action_get_english_category (PanelActionButtonType type);
+G_CONST_RETURN char *panel_action_get_tooltip          (PanelActionButtonType type);
+G_CONST_RETURN char *panel_action_get_drag_id          (PanelActionButtonType type);
 
 G_END_DECLS
 
diff -Nur gnome-panel-2.16.1/gnome-panel/panel-addto.c gnome-panel-2.16.1.new/gnome-panel/panel-addto.c
--- gnome-panel-2.16.1/gnome-panel/panel-addto.c	2006-10-03 01:10:37.000000000 +0200
+++ gnome-panel-2.16.1.new/gnome-panel/panel-addto.c	2006-10-03 01:13:30.000000000 +0200
@@ -26,117 +26,52 @@
 #include <string.h>
 
 #include <libbonobo.h>
+#include <libgnomecanvas/libgnomecanvas.h>
 
-#include "menu.h"
-
-#include "launcher.h"
-#include "panel.h"
-#include "drawer.h"
-#include "panel-applet-frame.h"
-#include "panel-action-button.h"
-#include "panel-menu-bar.h"
-#include "panel-separator.h"
-#include "panel-toplevel.h"
-#include "panel-menu-button.h"
-#include "panel-globals.h"
-#include "panel-lockdown.h"
-#include "panel-util.h"
-#include "panel-profile.h"
 #include "panel-addto.h"
+#include "panel-addto-canvas.h"
 
-typedef struct {
-	PanelWidget *panel_widget;
-
-	GtkWidget    *addto_dialog;
-	GtkWidget    *label;
-	GtkWidget    *search_entry;
-	GtkWidget    *back_button;
-	GtkWidget    *add_button;
-	GtkWidget    *tree_view;
-	GtkTreeModel *applet_model;
-	GtkTreeModel *filter_applet_model;
-	GtkTreeModel *application_model;
-	GtkTreeModel *filter_application_model;
-
-	GMenuTree    *menu_tree;
-
-	GSList       *applet_list;
-	GSList       *application_list;
-	GSList       *settings_list;
-
-	gchar        *search_text;
-	gchar        *applet_search_text;
-
-	guint         name_notify;
-
-	int           insertion_position;
-} PanelAddtoDialog;
-
+#define PANEL_ADDTO_CANVAS_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), PANEL_ADDTO_TYPE_CANVAS, PanelAddtoCanvasPrivate))
+	
 static GQuark panel_addto_dialog_quark = 0;
 
-typedef enum {
-	PANEL_ADDTO_APPLET,
-	PANEL_ADDTO_ACTION,
-	PANEL_ADDTO_LAUNCHER_MENU,
-	PANEL_ADDTO_LAUNCHER,
-	PANEL_ADDTO_LAUNCHER_NEW,
-	PANEL_ADDTO_MENU,
-	PANEL_ADDTO_MENUBAR,
-	PANEL_ADDTO_SEPARATOR,
-	PANEL_ADDTO_DRAWER
-} PanelAddtoItemType;
-
-typedef struct {
-	PanelAddtoItemType     type;
-	char                  *name;
-	char                  *description;
-	char                  *icon;
-	PanelActionButtonType  action_type;
-	char                  *launcher_path;
-	char                  *menu_filename;
-	char                  *menu_path;
-	char                  *iid;
-	gboolean               static_data;
-} PanelAddtoItemInfo;
-
-typedef struct {
-	GSList             *children;
-	PanelAddtoItemInfo  item_info;
-} PanelAddtoAppList;
-
-static PanelAddtoItemInfo special_addto_items [] = {
-
-	{ PANEL_ADDTO_LAUNCHER_NEW,
-	  N_("Custom Application Launcher"),
-	  N_("Create a new launcher"),
-	  "launcher-program",
-	  PANEL_ACTION_NONE,
-	  NULL,
-	  NULL,
-	  NULL,
-	  "LAUNCHER:ASK",
-	  TRUE },
-
-	{ PANEL_ADDTO_LAUNCHER_MENU,
-	  N_("Application Launcher..."),
-	  N_("Copy a launcher from the applications menu"),
-	  "launcher-program",
-	  PANEL_ACTION_NONE,
-	  NULL,
-	  NULL,
-	  NULL,
-	  "LAUNCHER:MENU",
-	  TRUE }
+typedef struct EntryInfo {
+       PanelAddtoCanvas *canvas;
 
-};
+       GnomeCanvasGroup     *group;
+       GnomeCanvasItem      *text;
+       GnomeCanvasItem      *pixbuf;
+       GnomeCanvasItem      *highlight_pixbuf;
+       GnomeCanvasItem      *cover;
+       GnomeCanvasItem      *selection;
+
+       double icon_height;
+       double icon_width;
+       double text_height;
+       guint  launching : 1;
+       guint  selected : 1;
+       guint  highlighted : 1;
+
+       gint n_category;
+       gint n_entry;
+       gint index;
+} EntryInfo;
+
+typedef struct CategoryInfo {
+       GnomeCanvasGroup *group;
+       GnomeCanvasItem  *title;
+       GnomeCanvasItem  *line;
+} CategoryInfo;
 
 static PanelAddtoItemInfo internal_addto_items [] = {
 
-	{ PANEL_ADDTO_MENU,
+        { PANEL_ADDTO_MENU,
+	  PANEL_ACTION_NONE,
+          N_("Utilities"),
+          "Utilities",
 	  N_("Main Menu"),
 	  N_("The main GNOME menu"),
 	  PANEL_MAIN_MENU_ICON,
-	  PANEL_ACTION_NONE,
 	  NULL,
 	  NULL,
 	  NULL,
@@ -144,10 +79,12 @@
 	  TRUE },
 
 	{ PANEL_ADDTO_MENUBAR,
+	  PANEL_ACTION_NONE,
+	  N_("Utilities"),
+	  "Utilities",
 	  N_("Menu Bar"),
 	  N_("A custom menu bar"),
 	  PANEL_GNOME_LOGO_ICON,
-	  PANEL_ACTION_NONE,
 	  NULL,
 	  NULL,
 	  NULL,
@@ -155,10 +92,12 @@
 	  TRUE },
 
 	{ PANEL_ADDTO_SEPARATOR,
+	  PANEL_ACTION_NONE,
+	  N_("Utilities"),
+	  "Utilities",
 	  N_("Separator"),
 	  N_("A separator to organize the panel items"),
 	  PANEL_SEPARATOR_ICON,
-	  PANEL_ACTION_NONE,
 	  NULL,
 	  NULL,
 	  NULL,
@@ -166,10 +105,12 @@
 	  TRUE },
 
 	{ PANEL_ADDTO_DRAWER,
+	  PANEL_ACTION_NONE,
+	  N_("Desktop &amp; Windows"),
+	  "Desktop &amp; Windows",
 	  N_("Drawer"),
 	  N_("A pop out drawer to store other items in"),
 	  PANEL_DRAWER_ICON,
-	  PANEL_ACTION_NONE,
 	  NULL,
 	  NULL,
 	  NULL,
@@ -202,9 +143,7 @@
 
 static void panel_addto_present_applications (PanelAddtoDialog *dialog);
 static void panel_addto_present_applets      (PanelAddtoDialog *dialog);
-static gboolean panel_addto_filter_func (GtkTreeModel *model,
-					 GtkTreeIter  *iter,
-					 gpointer      data);
+static void panel_addto_init_categories      (PanelAddtoDialog *dialog);
 
 static int
 panel_addto_applet_info_sort_func (PanelAddtoItemInfo *a,
@@ -223,6 +162,7 @@
 		if (!translated) {
 			internal_addto_items [i].name        = _(internal_addto_items [i].name);
 			internal_addto_items [i].description = _(internal_addto_items [i].description);
+			internal_addto_items [i].category    = _(internal_addto_items [i].category);
 		}
 
 		if (internal_addto_items [i].type == PANEL_ADDTO_MENU ||
@@ -245,14 +185,16 @@
 		if (panel_action_get_is_disabled (i))
 			continue;
 
-		info              = g_new0 (PanelAddtoItemInfo, 1);
-		info->type        = PANEL_ADDTO_ACTION;
-		info->action_type = i;
-		info->name        = g_strdup (panel_action_get_text (i));
-		info->description = g_strdup (panel_action_get_tooltip (i));
-		info->icon        = g_strdup (panel_action_get_icon_name (i));
-		info->iid         = g_strdup (panel_action_get_drag_id (i));
-		info->static_data = FALSE;
+		info                   = g_new0 (PanelAddtoItemInfo, 1);
+		info->type             = PANEL_ADDTO_ACTION;
+		info->action_type      = i;
+		info->name             = g_strdup (panel_action_get_text (i));
+		info->description      = g_strdup (panel_action_get_tooltip (i));
+		info->category         = g_strdup (panel_action_get_category (i));
+		info->english_category = g_strdup (panel_action_get_english_category (i));
+		info->icon             = g_strdup (panel_action_get_icon_name (i));
+		info->iid              = g_strdup (panel_action_get_drag_id (i));
+		info->static_data      = FALSE;
 
 		list = g_slist_prepend (list, info);
 	}
@@ -281,6 +223,7 @@
 }
 
 #define ICON_SIZE 32
+#define LAUNCHER_ICON_SIZE 20
 
 static GdkPixbuf *
 panel_addto_make_pixbuf (const char *filename)
@@ -292,8 +235,18 @@
 				NULL);
 }
 
+static GdkPixbuf *
+panel_addto_make_pixbuf_for_launcher (const char *filename)
+{
+	//FIXME: size shouldn't be fixed but should depend on the font size
+	return panel_load_icon (gtk_icon_theme_get_default (),
+				filename,
+				LAUNCHER_ICON_SIZE, LAUNCHER_ICON_SIZE, LAUNCHER_ICON_SIZE,
+				NULL);
+}
+
 static void  
-panel_addto_drag_data_get_cb (GtkWidget        *widget,
+panel_addto_applications_drag_data_get_cb (GtkWidget        *widget,
 			      GdkDragContext   *context,
 			      GtkSelectionData *selection_data,
 			      guint             info,
@@ -306,27 +259,22 @@
 }
 
 static void
-panel_addto_drag_begin_cb (GtkWidget      *widget,
+panel_addto_applications_drag_begin_cb (GtkWidget      *widget,
 			   GdkDragContext *context,
 			   gpointer        data)
 {
-	GtkTreeModel *filter_model;
-	GtkTreeModel *child_model;
+	GtkTreeModel *model;
 	GtkTreePath  *path;
 	GtkTreeIter   iter;
-	GtkTreeIter   filter_iter;
 	GdkPixbuf    *pixbuf;
 
-	filter_model = gtk_tree_view_get_model (GTK_TREE_VIEW (widget));
+	model = gtk_tree_view_get_model (GTK_TREE_VIEW (widget));
 	   
 	gtk_tree_view_get_cursor (GTK_TREE_VIEW (widget), &path, NULL);
-	gtk_tree_model_get_iter (filter_model, &filter_iter, path);
+	gtk_tree_model_get_iter (model, &iter, path);
 	gtk_tree_path_free (path);
-	gtk_tree_model_filter_convert_iter_to_child_iter (GTK_TREE_MODEL_FILTER (filter_model),
-							  &iter, &filter_iter);
 
-	child_model = gtk_tree_model_filter_get_model (GTK_TREE_MODEL_FILTER (filter_model));
-	gtk_tree_model_get (child_model, &iter,
+	gtk_tree_model_get (model, &iter,
 	                    COLUMN_ICON, &pixbuf,
 	                    -1);
 
@@ -335,7 +283,7 @@
 }
 
 static void
-panel_addto_setup_drag (GtkTreeView          *tree_view,
+panel_addto_applications_setup_drag (GtkTreeView          *tree_view,
 			const GtkTargetEntry *target,
 			const char           *text)
 {
@@ -347,17 +295,17 @@
 						target, 1, GDK_ACTION_COPY);
 	
 	g_signal_connect_data (G_OBJECT (tree_view), "drag_data_get",
-			       G_CALLBACK (panel_addto_drag_data_get_cb),
+			       G_CALLBACK (panel_addto_applications_drag_data_get_cb),
 			       g_strdup (text),
 			       (GClosureNotify) g_free,
 			       0 /* connect_flags */);
 	g_signal_connect_after (G_OBJECT (tree_view), "drag-begin",
-	                        G_CALLBACK (panel_addto_drag_begin_cb),
+	                        G_CALLBACK (panel_addto_applications_drag_begin_cb),
 	                        NULL);
 }
 
 static void
-panel_addto_setup_launcher_drag (GtkTreeView *tree_view,
+panel_addto_applications_setup_launcher_drag (GtkTreeView *tree_view,
 				 const char  *uri)
 {
         static GtkTargetEntry target[] = {
@@ -366,30 +314,19 @@
 	char *uri_list;
 
 	uri_list = g_strconcat (uri, "\r\n", NULL);
-	panel_addto_setup_drag (tree_view, target, uri_list);
+	panel_addto_applications_setup_drag (tree_view, target, uri_list);
 	g_free (uri_list);
 }
 
 static void
-panel_addto_setup_applet_drag (GtkTreeView *tree_view,
-			       const char  *iid)
-{
-	static GtkTargetEntry target[] = {
-		{ "application/x-panel-applet-iid", 0, 0 }
-	};
-
-	panel_addto_setup_drag (tree_view, target, iid);
-}
-
-static void
-panel_addto_setup_internal_applet_drag (GtkTreeView *tree_view,
+panel_addto_applications_setup_internal_applet_drag (GtkTreeView *tree_view,
 					const char  *applet_type)
 {
 	static GtkTargetEntry target[] = {
 		{ "application/x-panel-applet-internal", 0, 0 }
 	};
 
-	panel_addto_setup_drag (tree_view, target, applet_type);
+	panel_addto_applications_setup_drag (tree_view, target, applet_type);
 }
 
 static GSList *
@@ -428,20 +365,26 @@
 
 	for (i = 0; i < applet_list->_length; i++) {
 		Bonobo_ServerInfo *info;
-		const char *name, *description, *icon;
+		const char *name, *description, *category, *english_category, *icon;
 		PanelAddtoItemInfo *applet;
 
 		info = &applet_list->_buffer[i];
 
-		name = bonobo_server_info_prop_lookup (info,
-						       "name",
-						       langs_gslist);
-		description = bonobo_server_info_prop_lookup (info,
-							      "description",
-							      langs_gslist);
-		icon = bonobo_server_info_prop_lookup (info,
-						       "panel:icon",
-						       NULL);
+		name = bonobo_server_info_prop_lookup             (info,
+								   "name",
+								   langs_gslist);
+		description = bonobo_server_info_prop_lookup      (info,
+								   "description",
+								   langs_gslist);
+		category = bonobo_server_info_prop_lookup         (info,
+								   "panel:category",
+								   langs_gslist);
+		english_category = bonobo_server_info_prop_lookup (info,
+								   "panel:category",
+								   NULL);
+		icon = bonobo_server_info_prop_lookup             (info,
+								   "panel:icon",
+								   NULL);
 
 		if (!name ||
 		    panel_lockdown_is_applet_disabled (info->iid)) {
@@ -455,7 +398,13 @@
 		applet->icon = g_strdup (icon);
 		applet->iid = g_strdup (info->iid);
 		applet->static_data = FALSE;
-
+		if (!category) {
+			applet->category = g_strdup_printf (_("Miscellaneous"));			
+			applet->english_category = g_strdup_printf ("Miscellaneous");			
+		} else {
+			applet->category = g_markup_escape_text (category, -1);
+			applet->english_category = g_markup_escape_text (english_category, -1);
+		}
 		list = g_slist_prepend (list, applet);
 	}
 
@@ -508,38 +457,12 @@
 	}
 }
 
-static void
-panel_addto_append_special_applets (PanelAddtoDialog *dialog,
-				    GtkListStore *model)
-{
-	static gboolean translated = FALSE;
-	int i;
-	
-	for (i = 0; i < G_N_ELEMENTS (special_addto_items); i++) {
-		if (!translated) {
-			special_addto_items [i].name = _(special_addto_items [i].name);
-			special_addto_items [i].description = _(special_addto_items [i].description);
-		}
-
-		if (special_addto_items [i].type == PANEL_ADDTO_LAUNCHER_NEW
-		    && panel_lockdown_get_disable_command_line ())
-			continue;
-		
-		panel_addto_append_item (dialog, model, &special_addto_items [i]);
-	}
-	
-	translated = TRUE;
-}
-
-static void
+static GtkTreeModel *
 panel_addto_make_applet_model (PanelAddtoDialog *dialog)
 {
 	GtkListStore *model;
 	GSList       *l;
 
-	if (dialog->filter_applet_model != NULL)
-		return;
-
 	if (panel_profile_id_lists_are_writable ()) {
 		dialog->applet_list = panel_addto_query_applets (dialog->applet_list);
 		dialog->applet_list = panel_addto_prepend_internal_applets (dialog->applet_list);
@@ -554,21 +477,14 @@
 				    G_TYPE_POINTER,
 				    G_TYPE_STRING);
 
-	if (panel_profile_id_lists_are_writable ()) {
-		panel_addto_append_special_applets (dialog, model);
-		if (dialog->applet_list)
+	if (panel_profile_id_lists_are_writable () && dialog->applet_list) {
 			panel_addto_append_item (dialog, model, NULL);
 	}
 
 	for (l = dialog->applet_list; l; l = l->next)
 		panel_addto_append_item (dialog, model, l->data);
 
-	dialog->applet_model = GTK_TREE_MODEL (model);
-	dialog->filter_applet_model = gtk_tree_model_filter_new (GTK_TREE_MODEL (dialog->applet_model),
-								 NULL);
-	gtk_tree_model_filter_set_visible_func (GTK_TREE_MODEL_FILTER (dialog->filter_applet_model),
-						panel_addto_filter_func,
-						dialog, NULL);
+	return (GtkTreeModel *) model;
 }
 
 static void panel_addto_make_application_list (GSList             **parent_list,
@@ -726,16 +642,13 @@
 	}
 }
 
-static void
+static GtkTreeModel *
 panel_addto_make_application_model (PanelAddtoDialog *dialog)
 {
 	GtkTreeStore      *store;
 	GMenuTree          *tree;
 	GMenuTreeDirectory *root;
 
-	if (dialog->filter_application_model != NULL)
-		return;
-
 	store = gtk_tree_store_new (NUMBER_COLUMNS,
 				    GDK_TYPE_PIXBUF,
 				    G_TYPE_STRING,
@@ -777,20 +690,19 @@
 
 	gmenu_tree_unref (tree);
 
-	dialog->application_model = GTK_TREE_MODEL (store);
-	dialog->filter_application_model = gtk_tree_model_filter_new (GTK_TREE_MODEL (dialog->application_model),
-								      NULL);
-	gtk_tree_model_filter_set_visible_func (GTK_TREE_MODEL_FILTER (dialog->filter_application_model),
-						panel_addto_filter_func,
-						dialog, NULL);
+	return GTK_TREE_MODEL (store);
 }
 
-static void
+gboolean
 panel_addto_add_item (PanelAddtoDialog   *dialog,
 	 	      PanelAddtoItemInfo *item_info)
 {
+	gboolean destroy;
+	
 	g_assert (item_info != NULL);
 
+	destroy = TRUE;
+
 	switch (item_info->type) {
 	case PANEL_ADDTO_APPLET:
 		panel_applet_frame_create (dialog->panel_widget->toplevel,
@@ -804,6 +716,7 @@
 		break;
 	case PANEL_ADDTO_LAUNCHER_MENU:
 		panel_addto_present_applications (dialog);
+		destroy = FALSE;
 		break;
 	case PANEL_ADDTO_LAUNCHER:
 		panel_launcher_create (dialog->panel_widget->toplevel,
@@ -836,18 +749,21 @@
 				     NULL, FALSE, NULL);
 		break;
 	}
+
+	return destroy;
 }
 
-static void
+void
 panel_addto_dialog_response (GtkWidget *widget_dialog,
 			     guint response_id,
 			     PanelAddtoDialog *dialog)
 {
-	GtkTreeSelection *selection;
-	GtkTreeModel     *filter_model;
-	GtkTreeModel     *child_model;
-	GtkTreeIter       iter;
-	GtkTreeIter       filter_iter;
+	PanelAddtoItemInfo      *data;
+	PanelAddtoCanvasPrivate *priv;
+	PanelAddtoEntry         *selected_applet;
+        GtkTreeSelection        *selected_application;
+	GtkTreeModel            *model;
+	GtkTreeIter              iter;
 
 	switch (response_id) {
 	case GTK_RESPONSE_HELP:
@@ -856,28 +772,44 @@
 		break;
 
 	case PANEL_ADDTO_RESPONSE_ADD:
-		selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (dialog->tree_view));
-		if (gtk_tree_selection_get_selected (selection, &filter_model,
-						     &filter_iter)) {
-			PanelAddtoItemInfo *data;
-
-			gtk_tree_model_filter_convert_iter_to_child_iter (GTK_TREE_MODEL_FILTER (filter_model),
-									  &iter,
-									  &filter_iter);
-			child_model = gtk_tree_model_filter_get_model (GTK_TREE_MODEL_FILTER (filter_model));
-			gtk_tree_model_get (child_model, &iter,
-					    COLUMN_DATA, &data, -1);
 
-			if (data != NULL)
+                if (dialog->status == APPLETS) {
+                        priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (dialog->canvas);
+                        selected_applet = priv->selected;
+                        data = selected_applet->item_info;
+                        if (data) {
 				panel_addto_add_item (dialog, data);
-		}
+			}
+                } else if (dialog->status == APPLICATIONS) {
+                        selected_application = gtk_tree_view_get_selection (GTK_TREE_VIEW (dialog->tree_view));
+                        if (gtk_tree_selection_get_selected (selected_application,
+                                                             &model, &iter)) {
+                                gtk_tree_model_get (model, &iter,
+                                                    COLUMN_DATA, &data, -1);
+
+                                if (data != NULL) {
+                                        panel_addto_add_item (dialog, data);
+                                }
+                        }
+                }
+
 		break;
 
+
 	case PANEL_ADDTO_RESPONSE_BACK:
 		/* This response only happens when we're showing the
 		 * application list and the user wants to go back to the
 		 * applet list. */
-		panel_addto_present_applets (dialog);
+		gtk_widget_hide (dialog->applications_sw);
+                dialog->status = APPLETS;
+                panel_addto_present_applets (dialog);
+                gtk_widget_show_all  (dialog->applets_sw);
+                gtk_widget_show (dialog->statuslabel);
+                gtk_widget_show (dialog->search_entry);
+                gtk_widget_show (dialog->search_label);
+		gtk_widget_set_sensitive (dialog->launcher_button, TRUE);
+		if (!panel_lockdown_get_disable_command_line ())
+		  gtk_widget_set_sensitive (dialog->custom_launcher_button, TRUE);
 		break;
 
 	case GTK_RESPONSE_CLOSE:
@@ -890,6 +822,40 @@
 }
 
 static void
+panel_addto_add_launcher (PanelAddtoDialog *dialog)
+{
+  PanelAddtoEntry         *launcher_applet;
+  PanelAddtoItemInfo      *data;
+
+  launcher_applet = g_new (PanelAddtoEntry, 1);
+  data = launcher_applet->item_info;
+  data = g_new (PanelAddtoItemInfo, 1);
+  data->type = PANEL_ADDTO_LAUNCHER_MENU;
+
+  panel_addto_add_item (dialog, data);
+
+  g_free (launcher_applet);
+  g_free (data);
+}
+
+static void
+panel_addto_add_custom_launcher (PanelAddtoDialog *dialog)
+{
+  PanelAddtoEntry         *launcher_applet;
+  PanelAddtoItemInfo      *data;
+
+  launcher_applet = g_new (PanelAddtoEntry, 1);
+  data = launcher_applet->item_info;
+  data = g_new (PanelAddtoItemInfo, 1);
+  data->type = PANEL_ADDTO_LAUNCHER_NEW;
+
+  panel_addto_add_item (dialog, data);
+
+  g_free (launcher_applet);
+  g_free (data);
+}
+
+static void
 panel_addto_dialog_destroy (GtkWidget *widget_dialog,
 			    PanelAddtoDialog *dialog)
 {
@@ -899,45 +865,268 @@
 			    NULL);
 }
 
+
+static PanelAddtoCategory *
+panel_addto_category_new (const gchar *title,
+                         const gchar *english_title,
+                          gboolean     real_category)
+{
+       PanelAddtoCategory *retval;
+       retval = g_new0 (PanelAddtoCategory, 1);
+
+       retval->title = g_strdup (title);
+       retval->english_title = g_strdup (english_title);
+       retval->real_category = real_category != FALSE;
+       retval->entries = NULL;  /* We will populate it in init_categories */
+
+       return retval;
+}
+
+static int
+compare_categories (PanelAddtoCategory *a,
+                   PanelAddtoCategory *b)
+{
+       return g_utf8_collate (a->title, b->title);
+}
+
+static void
+panel_addto_init_categories (PanelAddtoDialog *dialog)
+{
+       PanelAddtoInformation *info;
+       PanelAddtoItemInfo    *applet;
+       PanelAddtoEntry       *entry;
+       PanelAddtoCategory    *current_category;
+       GSList                *categories = NULL;
+       GSList                *l, *m;
+       gchar                 *category_title, *category_english_title;
+       gboolean               found;
+
+       info = g_new0 (PanelAddtoInformation, 1);
+
+       for (l = dialog->applet_list; l; l = l->next) {
+                applet = l->data;
+               category_title = g_strdup (applet->category);
+               category_english_title = g_strdup (applet->english_category);
+               found = FALSE;
+               for (m = categories; m; m = m->next) {
+                       current_category = m->data;
+                       if (!g_utf8_collate (current_category->english_title, category_english_title)) {
+                               found = TRUE;
+                               current_category->n_entries++;
+                               if (!current_category->translated && strcmp (category_title, category_english_title)) {
+                                       current_category->title = category_title;
+                                       current_category->translated = TRUE;
+                               }
+                               break;
+                       }
+		}
+	        if (!found) {
+                       categories = g_slist_prepend (categories,
+                                                     panel_addto_category_new (category_title, category_english_title, TRUE));
+                       current_category = categories->data;
+                       current_category->translated = strcmp (category_title, category_english_title) ? TRUE : FALSE;
+                       current_category->n_entries = 1;
+		}
+
+               entry              = g_new0 (PanelAddtoEntry, 1);
+               entry->title       = g_strdup (applet->name);
+               entry->comment     = g_strdup (applet->description);
+               entry->item_info   = applet;
+               entry->category    = current_category;
+               entry->dialog      = dialog;
+               entry->icon_pixbuf = panel_addto_make_pixbuf (applet->icon);
+               current_category->entries = g_slist_append (current_category->entries, entry);
+       }
+
+       categories = g_slist_sort (categories,
+                                  (GCompareFunc) compare_categories);
+
+       info->n_categories = g_slist_length (categories);
+       info->categories   = categories;
+
+       dialog->info = info;
+}
+
+static gboolean
+panel_addto_separator_func (GtkTreeModel *model,
+			    GtkTreeIter *iter,
+			    gpointer data)
+{
+	int column = GPOINTER_TO_INT (data);
+	char *text;
+	
+	gtk_tree_model_get (model, iter, column, &text, -1);
+	
+	if (!text)
+		return TRUE;
+	
+	g_free(text);
+	return FALSE;
+}
+
+static void
+panel_addto_applications_selection_changed (GtkTreeSelection *selection,
+					    PanelAddtoDialog *dialog)
+{
+	GtkTreeModel       *model;
+	GtkTreeIter         iter;
+	PanelAddtoItemInfo *data;
+	char               *iid;
+
+
+	if (!gtk_tree_selection_get_selected (selection, &model, &iter)) {
+		gtk_widget_set_sensitive (GTK_WIDGET (dialog->add_button), FALSE);
+		return;
+	}
+
+	gtk_tree_model_get (model, &iter, COLUMN_DATA, &data, -1);
+
+	if (!data) {
+		gtk_widget_set_sensitive (GTK_WIDGET (dialog->add_button), FALSE);
+		return;
+	}
+
+	gtk_widget_set_sensitive (GTK_WIDGET (dialog->add_button), TRUE);
+
+	gtk_button_set_label (GTK_BUTTON (dialog->add_button),
+			      GTK_STOCK_ADD);
+	gtk_button_set_use_stock (GTK_BUTTON (dialog->add_button),
+				  TRUE);
+
+	/* only allow dragging applets if we can add applets */
+
+	if (panel_profile_id_lists_are_writable ()) {
+		switch (data->type) {
+		case PANEL_ADDTO_LAUNCHER:
+		  	panel_addto_applications_setup_launcher_drag (GTK_TREE_VIEW (dialog->tree_view),
+								      data->launcher_path);
+			break;
+		case PANEL_ADDTO_MENU:
+
+			/* build the iid for menus other than the main menu */
+
+			if (data->iid == NULL) {
+				iid = g_strdup_printf ("MENU:%s/%s",
+						       data->menu_filename,
+						       data->menu_path);
+			} else {
+				iid = g_strdup (data->iid);
+			}
+				panel_addto_applications_setup_internal_applet_drag (GTK_TREE_VIEW (dialog->tree_view),
+										     iid);
+			g_free (iid);
+			break;
+		default:
+			break;
+		}
+	}
+}
+
+
+static void
+panel_addto_applications_selection_activated (GtkTreeView       *view,
+					      GtkTreePath       *path,
+					      GtkTreeViewColumn *column,
+					      PanelAddtoDialog  *dialog)
+{
+	gtk_dialog_response (GTK_DIALOG (dialog->addto_dialog),
+			     PANEL_ADDTO_RESPONSE_ADD);
+}
+
 static void
 panel_addto_present_applications (PanelAddtoDialog *dialog)
 {
-	if (dialog->filter_application_model == NULL)
-		panel_addto_make_application_model (dialog);
-	gtk_tree_view_set_model (GTK_TREE_VIEW (dialog->tree_view),
-				 dialog->filter_application_model);
-	gtk_window_set_focus (GTK_WINDOW (dialog->addto_dialog),
-			      dialog->search_entry);
-	gtk_widget_set_sensitive (dialog->back_button, TRUE);
+        GtkTreeSelection  *selection;
+	GtkTreeViewColumn *column;
+
+        if (dialog->application_model == NULL) {
+        	dialog->application_model = panel_addto_make_application_model (dialog);
+	}
+	gtk_widget_hide (dialog->applets_sw);
+	gtk_widget_hide (dialog->statuslabel);
+	gtk_widget_hide (dialog->search_entry);
+	gtk_widget_hide (dialog->search_label);
+
+	gtk_widget_set_sensitive (dialog->launcher_button, FALSE);
+	gtk_widget_set_sensitive (dialog->custom_launcher_button, FALSE);
 
-	if (dialog->applet_search_text)
-		g_free (dialog->applet_search_text);
+	dialog->status = APPLICATIONS;
 
-	dialog->applet_search_text = g_strdup (gtk_entry_get_text (GTK_ENTRY (dialog->search_entry)));
-	/* show everything */
-	gtk_entry_set_text (GTK_ENTRY (dialog->search_entry), "");
+	dialog->applications_sw = gtk_scrolled_window_new (NULL, NULL);
+	gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (dialog->applications_sw),
+					GTK_POLICY_AUTOMATIC,
+					GTK_POLICY_AUTOMATIC);
+	gtk_scrolled_window_set_shadow_type (GTK_SCROLLED_WINDOW (dialog->applications_sw),
+					     GTK_SHADOW_IN);
+	dialog->tree_view = gtk_tree_view_new ();
+	gtk_tree_view_set_headers_visible (GTK_TREE_VIEW (dialog->tree_view),
+					   FALSE);
+	gtk_tree_view_expand_all (GTK_TREE_VIEW (dialog->tree_view));
+
+	dialog->renderer = g_object_new (GTK_TYPE_CELL_RENDERER_PIXBUF,
+					 "xpad", 4,
+					 "ypad", 4,
+					 NULL);
+
+	gtk_tree_view_insert_column_with_attributes (GTK_TREE_VIEW (dialog->tree_view),
+						     -1, NULL,
+						     dialog->renderer,
+						     "pixbuf", COLUMN_ICON,
+						     NULL);
+
+	dialog->renderer = gtk_cell_renderer_text_new ();
+	g_object_set (dialog->renderer, "ellipsize", PANGO_ELLIPSIZE_END, NULL);
+
+	gtk_tree_view_insert_column_with_attributes (GTK_TREE_VIEW (dialog->tree_view),
+						     -1, NULL,
+						     dialog->renderer,
+						     "markup", COLUMN_TEXT,
+						     NULL);
+	gtk_tree_view_set_search_column (GTK_TREE_VIEW (dialog->tree_view),
+					 COLUMN_SEARCH);
+
+	gtk_tree_view_set_row_separator_func (GTK_TREE_VIEW (dialog->tree_view),
+					      panel_addto_separator_func,
+					      GINT_TO_POINTER (COLUMN_TEXT),
+					      NULL);
+	selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (dialog->tree_view));
+	gtk_tree_selection_set_mode (selection, GTK_SELECTION_SINGLE);
+
+	column = gtk_tree_view_get_column (GTK_TREE_VIEW (dialog->tree_view),
+					   COLUMN_TEXT);
+	gtk_tree_view_column_set_sizing (column, GTK_TREE_VIEW_COLUMN_FIXED);
+
+	g_signal_connect (selection, "changed",
+			  G_CALLBACK (panel_addto_applications_selection_changed),
+			  dialog);
+
+	g_signal_connect (dialog->tree_view, "row-activated",
+			  G_CALLBACK (panel_addto_applications_selection_activated),
+			  dialog);
+
+        gtk_tree_view_set_model (GTK_TREE_VIEW (dialog->tree_view),
+				 dialog->application_model);
+        gtk_container_add    (GTK_CONTAINER (dialog->applications_sw),
+			      GTK_WIDGET (dialog->tree_view));
+	gtk_box_pack_start (GTK_BOX (dialog->inner_vbox), 
+			    GTK_WIDGET (dialog->applications_sw), TRUE, TRUE, 0);
+
+
+	gtk_window_set_focus (GTK_WINDOW (dialog->addto_dialog),
+			      dialog->tree_view);
+	gtk_widget_set_sensitive (dialog->back_button, TRUE);
+	gtk_widget_show_all (GTK_WIDGET (dialog->applications_sw));
 }
 
 static void
 panel_addto_present_applets (PanelAddtoDialog *dialog)
 {
-	if (dialog->filter_applet_model == NULL)
-		panel_addto_make_applet_model (dialog);
-	gtk_tree_view_set_model (GTK_TREE_VIEW (dialog->tree_view),
-				 dialog->filter_applet_model);
-	gtk_window_set_focus (GTK_WINDOW (dialog->addto_dialog),
-			      dialog->search_entry);
-	gtk_widget_set_sensitive (dialog->back_button, FALSE);
 
-	if (dialog->applet_search_text) {
-		gtk_entry_set_text (GTK_ENTRY (dialog->search_entry),
-				    dialog->applet_search_text);
-		gtk_editable_set_position (GTK_EDITABLE (dialog->search_entry),
-					   -1);
+	if (dialog->applet_model == NULL)
+		dialog->applet_model = panel_addto_make_applet_model (dialog);
 
-		g_free (dialog->applet_search_text);
-		dialog->applet_search_text = NULL;
-	}
+	gtk_widget_set_sensitive (dialog->back_button, FALSE);
+	
 }
 
 static void
@@ -998,8 +1187,10 @@
 static void
 panel_addto_dialog_free (PanelAddtoDialog *dialog)
 {
-	GConfClient *client;
-	GSList      *item;
+	GConfClient             *client;
+	GSList                  *item, *l, *m;
+	PanelAddtoCanvasPrivate *priv;
+	PanelAddtoCategory      *current_category;
 
 	client = panel_gconf_get_client ();
 
@@ -1007,18 +1198,14 @@
 		gconf_client_notify_remove (client, dialog->name_notify);
 	dialog->name_notify = 0;
 
-	if (dialog->search_text)
-		g_free (dialog->search_text);
-	dialog->search_text = NULL;
-
-	if (dialog->applet_search_text)
-		g_free (dialog->applet_search_text);
-	dialog->applet_search_text = NULL;
-
 	if (dialog->addto_dialog)
-		gtk_widget_destroy (dialog->addto_dialog);
+	        gtk_widget_destroy (dialog->addto_dialog);
 	dialog->addto_dialog = NULL;
-
+	
+	if (dialog->label) {
+	  dialog->label = NULL;
+	}
+	
 	for (item = dialog->applet_list; item != NULL; item = item->next) {
 		PanelAddtoItemInfo *applet;
 
@@ -1032,19 +1219,33 @@
 
 	panel_addto_dialog_free_application_list (dialog->application_list);
 	panel_addto_dialog_free_application_list (dialog->settings_list);
+		
+	if (dialog->canvas) {
+	        priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (dialog->canvas);
+	        if (priv) {
+		        if (priv && priv->info && priv->info->categories) {
+			  for (l = priv->info->categories; l; l = l->next) {
+			          current_category = l->data;
+				  for (m = current_category->entries; m; m = m->next) {
+				          g_free (m->data);
+				  }
+				  if (current_category->user_data)
+				          g_free (current_category->user_data);
+				  g_slist_free (current_category->entries);
+				  g_free (current_category);
+			  }
+			  g_slist_free (priv->info->categories);
+			}
+			g_free (priv->search_text);
+		}
+	}
 
-	if (dialog->filter_applet_model)
-		g_object_unref (dialog->filter_applet_model);
-	dialog->filter_applet_model = NULL;
+	
 
 	if (dialog->applet_model)
-		g_object_unref (dialog->applet_model);
+	  g_object_unref (dialog->applet_model);
 	dialog->applet_model = NULL;
 
-	if (dialog->filter_application_model)
-		g_object_unref (dialog->filter_application_model);
-	dialog->filter_application_model = NULL;
-
 	if (dialog->application_model)
 		g_object_unref (dialog->application_model);
 	dialog->application_model = NULL;
@@ -1066,17 +1267,18 @@
 	label = NULL;
 
 	if (!string_empty (name))
-		label = g_strdup_printf (_("Find an _item to add to \"%s\":"),
+		label = g_strdup_printf (_("Select an item to add to \"%s\":"),
 					 name);
 
 	if (panel_toplevel_get_is_attached (dialog->panel_widget->toplevel)) {
 		title = g_strdup_printf (_("Add to Drawer"));
 		if (label == NULL)
-			label = g_strdup (_("Find an _item to add to the drawer:"));
+			label = g_strdup (_("Select an item to add to the drawer:"));
 	} else {
 		title = g_strdup_printf (_("Add to Panel"));
 		if (label == NULL)
-			label = g_strdup (_("Find an _item to add to the panel:"));
+			label = g_strdup (_("Select an item to add to the panel \n\
+(you can also directly drag and drop items onto the panel):"));
 	}
 
 	gtk_window_set_title (GTK_WINDOW (dialog->addto_dialog), title);
@@ -1110,199 +1312,24 @@
 		panel_addto_name_change (dialog, text);
 }
 
-static gboolean
-panel_addto_filter_func (GtkTreeModel *model,
-			 GtkTreeIter  *iter,
-			 gpointer      userdata)
-{
-	PanelAddtoDialog   *dialog;
-	PanelAddtoItemInfo *data;
-
-	dialog = (PanelAddtoDialog *) userdata;
-
-	if (!dialog->search_text || !dialog->search_text[0])
-		return TRUE;
-
-	gtk_tree_model_get (model, iter, COLUMN_DATA, &data, -1);
-
-	if (data == NULL)
-		return FALSE;
-
-	/* This is more a workaround than anything else: show all the root
-	 * items in a tree store */
-	if (GTK_IS_TREE_STORE (model) &&
-	    gtk_tree_store_iter_depth (GTK_TREE_STORE (model), iter) == 0)
-		return TRUE;
-
-	return (panel_util_utf8_strstrcase (data->name,
-					    dialog->search_text) != NULL ||
-	        panel_util_utf8_strstrcase (data->description,
-					    dialog->search_text) != NULL);
-}
-
-static void
-panel_addto_search_entry_changed (GtkWidget        *entry,
-				  PanelAddtoDialog *dialog)
-{
-	GtkTreeModel *model;
-	char         *new_text;
-	GtkTreeIter   iter;
-	GtkTreePath  *path;
-
-	new_text = g_strdup (gtk_entry_get_text (GTK_ENTRY (dialog->search_entry)));
-	g_strchomp (new_text);
-		
-	if (dialog->search_text &&
-	    g_utf8_collate (new_text, dialog->search_text) == 0) {
-		g_free (new_text);
-		return;
-	}
-
-	if (dialog->search_text)
-		g_free (dialog->search_text);
-	dialog->search_text = new_text;
-
-	model = gtk_tree_view_get_model (GTK_TREE_VIEW (dialog->tree_view));
-	gtk_tree_model_filter_refilter (GTK_TREE_MODEL_FILTER (model));
-
-	path = gtk_tree_path_new_first ();
-	if (gtk_tree_model_get_iter (model, &iter, path)) {
-		GtkTreeSelection *selection;
-
-		gtk_tree_view_scroll_to_cell (GTK_TREE_VIEW (dialog->tree_view),
-					      path, NULL, FALSE, 0, 0);
-		selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (dialog->tree_view));
-		gtk_tree_selection_select_path (selection, path);
-	}
-	gtk_tree_path_free (path);
-}
-
-static void
-panel_addto_search_entry_activated (GtkWidget        *entry,
-				    PanelAddtoDialog *dialog)
-{
-	gtk_dialog_response (GTK_DIALOG (dialog->addto_dialog),
-			     PANEL_ADDTO_RESPONSE_ADD);
-}
-
-static void
-panel_addto_selection_changed (GtkTreeSelection *selection,
-			       PanelAddtoDialog *dialog)
-{
-	GtkTreeModel       *filter_model;
-	GtkTreeModel       *child_model;
-	GtkTreeIter         iter;
-	GtkTreeIter         filter_iter;
-	PanelAddtoItemInfo *data;
-	char               *iid;
-
-	if (!gtk_tree_selection_get_selected (selection,
-					      &filter_model,
-					      &filter_iter)) {
-		gtk_widget_set_sensitive (GTK_WIDGET (dialog->add_button),
-					  FALSE);
-		return;
-	}
-
-	gtk_tree_model_filter_convert_iter_to_child_iter (GTK_TREE_MODEL_FILTER (filter_model),
-							  &iter, &filter_iter);
-	child_model = gtk_tree_model_filter_get_model (GTK_TREE_MODEL_FILTER (filter_model));
-	gtk_tree_model_get (child_model, &iter, COLUMN_DATA, &data, -1);
-
-	if (!data) {
-		gtk_widget_set_sensitive (GTK_WIDGET (dialog->add_button),
-					  FALSE);
-		return;
-	}
-
-	gtk_widget_set_sensitive (GTK_WIDGET (dialog->add_button), TRUE);
-
-	if (data->type == PANEL_ADDTO_LAUNCHER_MENU) {
-		gtk_button_set_label (GTK_BUTTON (dialog->add_button),
-				      GTK_STOCK_GO_FORWARD);
-	} else {
-		gtk_button_set_label (GTK_BUTTON (dialog->add_button),
-				      GTK_STOCK_ADD);
-	}
-	gtk_button_set_use_stock (GTK_BUTTON (dialog->add_button),
-				  TRUE);
-
-	/* only allow dragging applets if we can add applets */
-	if (panel_profile_id_lists_are_writable ()) {
-		switch (data->type) {
-		case PANEL_ADDTO_LAUNCHER:
-			panel_addto_setup_launcher_drag (GTK_TREE_VIEW (dialog->tree_view),
-							 data->launcher_path);
-			break;
-		case PANEL_ADDTO_APPLET:
-			panel_addto_setup_applet_drag (GTK_TREE_VIEW (dialog->tree_view),
-						       data->iid);
-			break;
-		case PANEL_ADDTO_LAUNCHER_MENU:
-			gtk_tree_view_unset_rows_drag_source (GTK_TREE_VIEW (dialog->tree_view));
-			break;
-		case PANEL_ADDTO_MENU:
-			/* build the iid for menus other than the main menu */
-			if (data->iid == NULL) {
-				iid = g_strdup_printf ("MENU:%s/%s",
-						       data->menu_filename,
-						       data->menu_path);
-			} else {
-				iid = g_strdup (data->iid);
-			}
-			panel_addto_setup_internal_applet_drag (GTK_TREE_VIEW (dialog->tree_view),
-							        iid);
-			g_free (iid);
-			break;
-		default:
-			panel_addto_setup_internal_applet_drag (GTK_TREE_VIEW (dialog->tree_view),
-							        data->iid);
-			break;
-		}
-	}
-}
-
-static void
-panel_addto_selection_activated (GtkTreeView       *view,
-				 GtkTreePath       *path,
-				 GtkTreeViewColumn *column,
-				 PanelAddtoDialog  *dialog)
-{
-	gtk_dialog_response (GTK_DIALOG (dialog->addto_dialog),
-			     PANEL_ADDTO_RESPONSE_ADD);
-}
-
-static gboolean
-panel_addto_separator_func (GtkTreeModel *model,
-			    GtkTreeIter *iter,
-			    gpointer data)
-{
-	int column = GPOINTER_TO_INT (data);
-	char *text;
-	
-	gtk_tree_model_get (model, iter, column, &text, -1);
-	
-	if (!text)
-		return TRUE;
-	
-	g_free(text);
-	return FALSE;
-}
 
 static PanelAddtoDialog *
 panel_addto_dialog_new (PanelWidget *panel_widget)
 {
 	PanelAddtoDialog *dialog;
-	GtkWidget *vbox;
-	GtkWidget *inner_vbox;
-	GtkWidget *find_hbox;
-	GtkWidget *sw;
-	GtkCellRenderer *renderer;
-	GtkTreeSelection *selection;
-	GtkTreeViewColumn *column;
+	GtkWidget        *vbox;
+	GtkWidget        *top_hbox;
+	GtkWidget        *launchers_hbox;
+	GdkPixbuf        *launcher_pixbuf;
+	GtkWidget        *launcher_image;
+	GtkWidget        *bottom_hbox;
+	GtkTooltips      *launchers_tooltips;
+	GtkImage         *label_image;
 
 	dialog = g_new0 (PanelAddtoDialog, 1);
 
+	dialog->status = APPLETS;
+
 	g_object_set_qdata_full (G_OBJECT (panel_widget->toplevel),
 				 panel_addto_dialog_quark,
 				 dialog,
@@ -1310,14 +1337,14 @@
 
 	dialog->panel_widget = panel_widget;
 	dialog->name_notify =
-		panel_profile_toplevel_notify_add (
-			dialog->panel_widget->toplevel,
-			"name",
-			(GConfClientNotifyFunc) panel_addto_name_notify,
-			dialog);
-
-
+	panel_profile_toplevel_notify_add (dialog->panel_widget->toplevel,
+	                                   "name",
+	                                   (GConfClientNotifyFunc) panel_addto_name_notify,
+	                                    dialog);
 	dialog->addto_dialog = gtk_dialog_new ();
+
+	dialog->statuslabel = gtk_label_new ("");
+	
 	gtk_dialog_add_button (GTK_DIALOG (dialog->addto_dialog),
 			       GTK_STOCK_HELP, GTK_RESPONSE_HELP);
 	dialog->back_button = gtk_dialog_add_button (GTK_DIALOG (dialog->addto_dialog),
@@ -1345,104 +1372,103 @@
 	vbox = gtk_vbox_new (FALSE, 12);
 	gtk_container_set_border_width (GTK_CONTAINER (vbox), 5);
 	gtk_container_add (GTK_CONTAINER (GTK_DIALOG (dialog->addto_dialog)->vbox),
-			   vbox);
-
-	inner_vbox = gtk_vbox_new (FALSE, 6);
-	gtk_box_pack_start (GTK_BOX (vbox), inner_vbox, TRUE, TRUE, 0);
+			   GTK_WIDGET (vbox));
 
-	find_hbox = gtk_hbox_new (FALSE, 6);
-	gtk_box_pack_start (GTK_BOX (inner_vbox), find_hbox, FALSE, FALSE, 0);
+	dialog->inner_vbox = gtk_vbox_new (FALSE, 6);
+	gtk_box_pack_start (GTK_BOX (vbox), dialog->inner_vbox, TRUE, TRUE, 0);
 
+	top_hbox       = gtk_hbox_new (FALSE, 6);
+	launchers_hbox = gtk_hbox_new (FALSE, 6);
+	bottom_hbox    = gtk_hbox_new (FALSE, 0);
 	dialog->label = gtk_label_new_with_mnemonic ("");
 	gtk_misc_set_alignment (GTK_MISC (dialog->label), 0.0, 0.5);
 	gtk_label_set_use_markup (GTK_LABEL (dialog->label), TRUE);
 
-	gtk_box_pack_start (GTK_BOX (find_hbox), dialog->label,
-			    FALSE, FALSE, 0);
+	label_image = g_object_new (GTK_TYPE_IMAGE,
+	                            "stock", GTK_STOCK_DIALOG_INFO,
+	                            "icon-size", GTK_ICON_SIZE_DND,
+	                            NULL);
+	dialog->search_label = gtk_label_new_with_mnemonic (_("_Search: "));
+	dialog->search_entry = gtk_entry_new ();
+	g_strdup (gtk_entry_get_text (GTK_ENTRY (dialog->search_entry)));
+	gtk_label_set_mnemonic_widget (GTK_LABEL (dialog->search_label), GTK_WIDGET (dialog->search_entry));
 
-	dialog->search_entry = gtk_entry_new (); 
 	g_signal_connect (G_OBJECT (dialog->search_entry), "changed",
-			  G_CALLBACK (panel_addto_search_entry_changed), dialog);
+			  G_CALLBACK (panel_addto_relayout_for_search), dialog);
 	g_signal_connect (G_OBJECT (dialog->search_entry), "activate",
-			  G_CALLBACK (panel_addto_search_entry_activated), dialog);
-
-	gtk_box_pack_end (GTK_BOX (find_hbox), dialog->search_entry,
-			  TRUE, TRUE, 0);
-
-	gtk_label_set_mnemonic_widget (GTK_LABEL (dialog->label),
-				       dialog->search_entry);
-
-	sw = gtk_scrolled_window_new (NULL, NULL);
-	gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (sw),
-					GTK_POLICY_AUTOMATIC,
-					GTK_POLICY_AUTOMATIC);
-	gtk_scrolled_window_set_shadow_type (GTK_SCROLLED_WINDOW (sw),
-					     GTK_SHADOW_IN);
-	gtk_box_pack_start (GTK_BOX (inner_vbox), sw, TRUE, TRUE, 0);
-
-	dialog->tree_view = gtk_tree_view_new ();
-	gtk_tree_view_set_headers_visible (GTK_TREE_VIEW (dialog->tree_view),
-					   FALSE);
-	gtk_tree_view_expand_all (GTK_TREE_VIEW (dialog->tree_view));
+			  G_CALLBACK (panel_addto_activate_from_searchbar), dialog);
+	
+	gtk_box_pack_start (GTK_BOX (top_hbox), GTK_WIDGET(label_image),
+			    FALSE, FALSE, 0);
+	
+	gtk_box_pack_start (GTK_BOX (top_hbox), dialog->label,
+			    TRUE, TRUE, 0);
+	
+	gtk_box_pack_start (GTK_BOX (top_hbox), GTK_WIDGET (dialog->search_label),
+                            FALSE, FALSE, 0);
 
-	renderer = g_object_new (GTK_TYPE_CELL_RENDERER_PIXBUF,
-				 "xpad", 4,
-				 "ypad", 4,
-				 NULL);
+	gtk_box_pack_start (GTK_BOX (top_hbox), GTK_WIDGET (dialog->search_entry),
+                            TRUE, TRUE, 0);
 
-	gtk_tree_view_insert_column_with_attributes (GTK_TREE_VIEW (dialog->tree_view),
-						     -1, NULL,
-						     renderer,
-						     "pixbuf", COLUMN_ICON,
-						     NULL);
-	renderer = gtk_cell_renderer_text_new ();
-	g_object_set (renderer, "ellipsize", PANGO_ELLIPSIZE_END, NULL);
-	gtk_tree_view_insert_column_with_attributes (GTK_TREE_VIEW (dialog->tree_view),
-						     -1, NULL,
-						     renderer,
-						     "markup", COLUMN_TEXT,
-						     NULL);
+	gtk_box_pack_start (GTK_BOX (dialog->inner_vbox), top_hbox,
+			    FALSE, FALSE, 0);
 
-	//FIXME use the same search than the one for the search entry?
-	gtk_tree_view_set_search_column (GTK_TREE_VIEW (dialog->tree_view),
-					 COLUMN_SEARCH);
+	/* Launcher button */
+	launchers_tooltips = gtk_tooltips_new ();
+	dialog->launcher_button = gtk_button_new_with_mnemonic (_("A_pplication Launcher..."));
+	launcher_pixbuf = panel_addto_make_pixbuf_for_launcher ("launcher-program");
+	launcher_image = gtk_image_new_from_pixbuf (launcher_pixbuf);
+	gtk_button_set_image (GTK_BUTTON (dialog->launcher_button), launcher_image);
+	gtk_tooltips_set_tip (launchers_tooltips, dialog->launcher_button, _("Launch a program that is already in the GNOME menu"), NULL);
+	g_signal_connect_swapped (dialog->launcher_button, "clicked",
+				  G_CALLBACK (panel_addto_add_launcher), dialog);
+	gtk_box_pack_start (GTK_BOX (launchers_hbox), dialog->launcher_button,
+			    FALSE, FALSE, 0);
 
-	gtk_tree_view_set_row_separator_func (GTK_TREE_VIEW (dialog->tree_view),
-					      panel_addto_separator_func,
-					      GINT_TO_POINTER (COLUMN_TEXT),
-					      NULL);
-					      
+	/* Custom launcher button*/
+	dialog->custom_launcher_button = gtk_button_new_with_mnemonic (_("Custom Application _Launcher"));
+	launcher_image = gtk_image_new_from_pixbuf (launcher_pixbuf);
+	gtk_button_set_image (GTK_BUTTON (dialog->custom_launcher_button), launcher_image);
+	gtk_tooltips_set_tip (launchers_tooltips, dialog->custom_launcher_button, _("Create a new launcher"), NULL);
+	g_signal_connect_swapped (dialog->custom_launcher_button, "clicked",
+				  G_CALLBACK (panel_addto_add_custom_launcher), dialog);
+	gtk_box_pack_start (GTK_BOX (launchers_hbox), dialog->custom_launcher_button,
+			    FALSE, FALSE, 0);
 
-	selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (dialog->tree_view));
-	gtk_tree_selection_set_mode (selection, GTK_SELECTION_SINGLE);
+	if (panel_lockdown_get_disable_command_line ())
+	  gtk_widget_set_sensitive (dialog->custom_launcher_button, FALSE);
 
-	column = gtk_tree_view_get_column (GTK_TREE_VIEW (dialog->tree_view),
-					   COLUMN_TEXT);
-	gtk_tree_view_column_set_sizing (column, GTK_TREE_VIEW_COLUMN_FIXED);
+	gtk_box_pack_start (GTK_BOX (dialog->inner_vbox), launchers_hbox,
+			    FALSE, FALSE, 0);
 
-	g_signal_connect (selection, "changed",
-			  G_CALLBACK (panel_addto_selection_changed),
-			  dialog);
+	dialog->applets_sw = gtk_scrolled_window_new (NULL, NULL);
+	gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (dialog->applets_sw),
+					GTK_POLICY_AUTOMATIC,
+					GTK_POLICY_AUTOMATIC);
+	gtk_scrolled_window_set_shadow_type (GTK_SCROLLED_WINDOW (dialog->applets_sw),
+   					     GTK_SHADOW_IN);
 
-	g_signal_connect (dialog->tree_view, "row-activated",
-			  G_CALLBACK (panel_addto_selection_activated),
-			  dialog);
+	gtk_box_pack_start (GTK_BOX (dialog->inner_vbox), dialog->applets_sw, TRUE, TRUE, 0);
+	gtk_box_pack_start (GTK_BOX (bottom_hbox), dialog->statuslabel, FALSE, FALSE, 0);
 
-	gtk_container_add (GTK_CONTAINER (sw), dialog->tree_view);
+	gtk_box_pack_start (GTK_BOX (dialog->inner_vbox), bottom_hbox,
+			    FALSE, FALSE, 0);
 
 	gtk_widget_show_all (vbox);
 
+	gtk_label_set_mnemonic_widget (GTK_LABEL (dialog->label),
+				       dialog->canvas);
+
 	panel_toplevel_push_autohide_disabler (dialog->panel_widget->toplevel);
 	panel_widget_register_open_dialog (panel_widget,
 					   dialog->addto_dialog);
-
 	panel_addto_name_change (dialog,
 				 panel_toplevel_get_name (dialog->panel_widget->toplevel));
 
 	return dialog;
 }
 
-#define MAX_ADDTOPANEL_HEIGHT 490
+#define MAX_ADDTOPANEL_HEIGHT 540
 
 void
 panel_addto_present (GtkMenuItem *item,
@@ -1451,6 +1477,7 @@
 	PanelAddtoDialog *dialog;
 	PanelToplevel *toplevel;
 	PanelData     *pd;
+	GtkAdjustment *sw_adjustment = NULL;
 	GdkScreen *screen;
 	gint screen_height;
 	gint height;
@@ -1471,12 +1498,24 @@
 
 	if (!dialog) {
 		dialog = panel_addto_dialog_new (panel_widget);
+
 		panel_addto_present_applets (dialog);
+		panel_addto_init_categories (dialog);
+
+		dialog->canvas = panel_addto_canvas_new (dialog->info);
+       		gtk_container_add (GTK_CONTAINER (dialog->applets_sw), 
+				   GTK_WIDGET (dialog->canvas));
 	}
 
+	sw_adjustment = gtk_scrolled_window_get_vadjustment (GTK_SCROLLED_WINDOW (dialog->applets_sw));
 	dialog->insertion_position = pd ? pd->insertion_pos : -1;
 	gtk_window_set_screen (GTK_WINDOW (dialog->addto_dialog), screen);
 	gtk_window_set_default_size (GTK_WINDOW (dialog->addto_dialog),
-				     height * 8 / 7, height);
+				     height * 1.35, height);
 	gtk_window_present (GTK_WINDOW (dialog->addto_dialog));
+	
+	sw_adjustment->value = sw_adjustment->lower;
+	sw_adjustment->step_increment = 55;
+	gtk_adjustment_clamp_page (sw_adjustment, sw_adjustment->lower, sw_adjustment->upper);
+	gtk_scrolled_window_set_vadjustment (GTK_SCROLLED_WINDOW (dialog->applets_sw), sw_adjustment);
 }
diff -Nur gnome-panel-2.16.1/gnome-panel/panel-addto-canvas.c gnome-panel-2.16.1.new/gnome-panel/panel-addto-canvas.c
--- gnome-panel-2.16.1/gnome-panel/panel-addto-canvas.c	1970-01-01 01:00:00.000000000 +0100
+++ gnome-panel-2.16.1.new/gnome-panel/panel-addto-canvas.c	2006-10-03 01:10:39.000000000 +0200
@@ -0,0 +1,2309 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+/* Copyright (C) 2005 Carlos Garnacho
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Authors: Jody Goldberg          <jody@gnome.org>
+ *          Carlos Garnacho Parro  <carlosg@gnome.org>
+ *          Manu Cornet            <manu@manucornet.net>
+ */
+
+
+#include "panel-addto-canvas.h"
+#include "panel-addto.h"
+#include "panel-profile.h"
+
+#define PAD 5 /*when scrolling keep a few pixels above or below if possible */
+#define ABOVE_LINE_SPACING 0
+#define UNDER_LINE_SPACING 0
+#define UNDER_TITLE_SPACING 0 /* manually insert 1 blank line of text */
+#define LINE_HEIGHT 1
+#define BORDERS 7
+#define MAX_ITEM_WIDTH	125
+#define ITEMS_SEPARATION 7
+
+#include "panel-addto-canvas.h"
+#include "panel-addto-event-box.h"
+#include "panel-addto-rounded-rect.h"
+
+#include <libgnomecanvas/libgnomecanvas.h>
+#include <libgnome/gnome-desktop-item.h>
+#include <gconf/gconf-client.h>
+#include <gdk/gdkkeysyms.h>
+#include <atk/atk.h>
+
+#define PANEL_ADDTO_CANVAS_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), PANEL_ADDTO_TYPE_CANVAS, PanelAddtoCanvasPrivate))
+
+typedef struct EntryInfo {
+	PanelAddtoCanvas *canvas;
+
+	GnomeCanvasGroup     *group;
+	GnomeCanvasItem      *text;
+	GnomeCanvasItem      *pixbuf;
+	GnomeCanvasItem      *highlight_pixbuf;
+	GnomeCanvasItem      *cover;
+	GnomeCanvasItem      *selection;
+
+	double    icon_height;
+	double    icon_width;
+	double    text_height;
+	guint     launching : 1;
+	guint     selected : 1;
+	guint     highlighted : 1;
+	gboolean  visible;
+
+	gint n_category;
+	gint n_entry;
+	gint index;
+} EntryInfo;
+
+typedef struct {
+	GnomeCanvasGroup *group;
+	GnomeCanvasItem  *title;
+	GnomeCanvasItem  *line;
+	gboolean          visible;
+} CategoryInfo;
+
+enum {
+	SELECTION_CHANGED,
+	LAST_SIGNAL
+};
+
+enum {
+	PROP_0,
+	PROP_INFO
+};
+
+
+static guint panel_addto_canvas_signals [LAST_SIGNAL] = { 0 };
+
+
+static void panel_addto_canvas_class_init (PanelAddtoCanvasClass *class);
+static void panel_addto_canvas_init       (PanelAddtoCanvas      *canvas);
+static void panel_addto_canvas_finalize   (GObject            *object);
+static void panel_addto_canvas_set_property (GObject      *object,
+					     guint         prop_id,
+					     const GValue *value,
+					     GParamSpec   *pspec);
+static void panel_addto_canvas_get_property (GObject      *object,
+					     guint         prop_id,
+					     GValue       *value,
+					     GParamSpec   *pspec);
+static void panel_addto_canvas_draw_background (GnomeCanvas *canvas, GdkDrawable *drawable,
+					    int x, int y, int width, int height);
+static void panel_addto_canvas_size_allocate   (GtkWidget     *canvas,
+						GtkAllocation *allocation);
+static void panel_addto_canvas_style_set       (GtkWidget     *canvas,
+						GtkStyle      *previous_style);
+static void panel_addto_canvas_realize         (GtkWidget     *canvas);
+
+static void panel_addto_select_east_entry (EntryInfo *ei, PanelAddtoCanvas *canvas);
+static void build_canvas (PanelAddtoCanvas *canvas);
+static void relayout_canvas (PanelAddtoCanvas *canvas);
+static void set_style (PanelAddtoCanvas *canvas, gboolean font_changed);
+
+G_DEFINE_TYPE (PanelAddtoCanvas, panel_addto_canvas, GNOME_TYPE_CANVAS);
+
+
+static AtkObject* panel_addto_canvas_get_accessible (GtkWidget *widget);
+
+#include "panel-addto-event-box.h"
+#include "panel-addto-rounded-rect.h"
+#include "panel-profile.h"
+
+static void
+panel_addto_canvas_class_init (PanelAddtoCanvasClass *class)
+{
+	GObjectClass     *object_class = G_OBJECT_CLASS (class);
+	GnomeCanvasClass *canvas_class = GNOME_CANVAS_CLASS (class);
+	GtkWidgetClass   *widget_class = GTK_WIDGET_CLASS (class);
+
+	object_class->set_property = panel_addto_canvas_set_property;
+	object_class->get_property = panel_addto_canvas_get_property;
+	object_class->finalize = panel_addto_canvas_finalize;
+	canvas_class->draw_background = panel_addto_canvas_draw_background;
+
+	widget_class->style_set = panel_addto_canvas_style_set;
+	widget_class->size_allocate = panel_addto_canvas_size_allocate;
+	widget_class->realize = panel_addto_canvas_realize;
+	widget_class->get_accessible = panel_addto_canvas_get_accessible;
+
+	class->changed = NULL;
+
+	g_object_class_install_property (object_class,
+					 PROP_INFO,
+					 g_param_spec_pointer ("info",
+							       "information for the canvas",
+							       "information for the canvas",
+							       G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
+	panel_addto_canvas_signals [SELECTION_CHANGED] =
+		g_signal_new ("selection-changed",
+			      G_OBJECT_CLASS_TYPE (object_class),
+			      G_SIGNAL_RUN_LAST,
+			      G_STRUCT_OFFSET (PanelAddtoCanvasClass, changed),
+			      NULL, NULL,
+			      g_cclosure_marshal_VOID__STRING,
+			      G_TYPE_NONE, 1,
+			      G_TYPE_STRING);
+
+	g_type_class_add_private (object_class,
+				  sizeof (PanelAddtoCanvasPrivate));
+}
+
+
+static void
+panel_addto_canvas_init (PanelAddtoCanvas *canvas)
+{
+	PanelAddtoCanvasPrivate *priv;
+	
+	g_return_if_fail (PANEL_ADDTO_IS_CANVAS (canvas));
+
+	priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+
+	priv->max_width = 300;
+	priv->min_height = 0;
+	priv->info = NULL;
+	priv->selected = NULL;
+
+	priv->max_item_width = 0;
+	priv->max_item_height = 0;
+	priv->items_per_row = 0;
+	priv->rtl = (gtk_widget_get_direction (GTK_WIDGET (canvas)) == GTK_TEXT_DIR_RTL);
+	priv->accessible_children = g_hash_table_new (g_int_hash, g_int_equal);
+
+	gtk_widget_show_all (GTK_WIDGET (canvas));
+}
+
+static void
+panel_addto_canvas_set_property (GObject      *object,
+			     guint         prop_id,
+			     const GValue *value,
+			     GParamSpec   *pspec)
+{
+	PanelAddtoCanvasPrivate *priv;
+
+	priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (object);
+
+	switch (prop_id) {
+	case PROP_INFO:
+		priv->info = g_value_get_pointer (value);
+		build_canvas (PANEL_ADDTO_CANVAS (object));
+		break;
+	}
+}
+
+static void
+panel_addto_canvas_get_property (GObject      *object,
+			     guint         prop_id,
+			     GValue       *value,
+			     GParamSpec   *pspec)
+{
+	PanelAddtoCanvasPrivate *priv;
+
+	priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (object);
+
+	switch (prop_id) {
+	case PROP_INFO:
+		g_value_set_pointer (value, priv->info);
+		break;
+	}
+}
+
+static void
+panel_addto_canvas_finalize (GObject *object)
+{
+	if (G_OBJECT_CLASS (panel_addto_canvas_parent_class)->finalize)
+		(* G_OBJECT_CLASS (panel_addto_canvas_parent_class)->finalize) (object);
+}
+
+
+static void
+panel_addto_canvas_draw_background (GnomeCanvas *canvas, GdkDrawable *drawable,
+				int x, int y, int width, int height)
+{
+	/* By default, we use the style base color. */
+	gdk_gc_set_foreground (canvas->pixmap_gc,
+			       &GTK_WIDGET (canvas)->style->base[GTK_STATE_NORMAL]);
+	gdk_draw_rectangle (drawable,
+			    canvas->pixmap_gc,
+			    TRUE,
+			    0, 0,
+			    width, height);
+}
+
+static void
+panel_addto_canvas_size_allocate(GtkWidget *canvas, GtkAllocation *allocation)
+{
+	PanelAddtoCanvasPrivate *priv;
+
+	if (GTK_WIDGET_CLASS (panel_addto_canvas_parent_class)->size_allocate)
+		(* GTK_WIDGET_CLASS (panel_addto_canvas_parent_class)->size_allocate) (canvas, allocation);
+
+	if (allocation->height == 1 || allocation->width == 1)
+		return;
+
+	priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+	priv->max_width = allocation->width;
+	priv->min_height = allocation->height;
+
+	relayout_canvas (PANEL_ADDTO_CANVAS (canvas));
+
+	gnome_canvas_set_scroll_region (GNOME_CANVAS (canvas), 0, 0, priv->width - 1, priv->height - 1);
+	g_object_set (priv->under_cover,
+		      "x2", priv->width,
+		      "y2", priv->height,
+		      NULL);
+}
+
+static void
+panel_addto_canvas_realize (GtkWidget *canvas)
+{
+	if (GTK_WIDGET_CLASS (panel_addto_canvas_parent_class)->realize)
+		(* GTK_WIDGET_CLASS (panel_addto_canvas_parent_class)->realize) (canvas);
+
+	set_style (PANEL_ADDTO_CANVAS (canvas), FALSE);
+}
+
+static void
+panel_addto_canvas_style_set (GtkWidget *canvas, GtkStyle *previous_style)
+{
+	if (!GTK_WIDGET_REALIZED (canvas))
+		return;
+
+	set_style (PANEL_ADDTO_CANVAS (canvas), (previous_style &&
+					     canvas->style &&
+					     !pango_font_description_equal (canvas->style->font_desc,
+									    previous_style->font_desc)));
+}
+
+static void
+gnome_canvas_item_show_hide (GnomeCanvasItem *item, gboolean show)
+{
+	if (show)
+		gnome_canvas_item_show (item);
+	else
+		gnome_canvas_item_hide (item);
+}
+
+static void
+setup_entry (PanelAddtoCanvas *canvas, PanelAddtoEntry *entry)
+{
+	PanelAddtoCanvasPrivate *priv;
+	EntryInfo *ei;
+	GtkWidget *widget;
+	GtkStateType state;
+
+	if (!entry)
+		return;
+
+	priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+	widget = GTK_WIDGET (canvas);
+	ei = entry->user_data;
+
+	if (ei->pixbuf) {
+		gnome_canvas_item_show_hide (ei->highlight_pixbuf, ei->highlighted);
+		gnome_canvas_item_show_hide (ei->pixbuf, !ei->highlighted);
+	}
+	if (!ei->selected)
+		state = GTK_STATE_NORMAL;
+	else if (gtk_window_has_toplevel_focus (GTK_WINDOW (gtk_widget_get_toplevel (widget))))
+		state = GTK_STATE_SELECTED;
+	else
+		state = GTK_STATE_ACTIVE;
+	gnome_canvas_item_show_hide (ei->selection, ei->selected);
+	g_object_set (ei->selection,
+		      "fill_color_gdk", &widget->style->base [state],
+		      NULL);
+	g_object_set (ei->text,
+		      "fill_color_gdk", &widget->style->text [state],
+		      NULL);
+}
+
+static gboolean
+cb_entry_info_reset (gpointer data)
+{
+	EntryInfo *ei = data;
+	ei->launching = FALSE;
+	return FALSE;
+}
+
+
+void
+activate_entry (PanelAddtoEntry *entry)
+{
+	EntryInfo *ei = entry->user_data;
+
+	if (!ei->launching) {
+		ei->launching = TRUE;
+		gtk_timeout_add (1000, cb_entry_info_reset, ei);
+
+		if (panel_addto_add_item (entry->dialog, entry->item_info))
+			gtk_widget_destroy (entry->dialog->addto_dialog);
+		}
+}
+
+static void  
+panel_addto_drag_data_get_cb (GtkWidget        *widget,
+			      GdkDragContext   *context,
+			      GtkSelectionData *selection_data,
+			      guint             info,
+			      guint             time,
+			      const char       *string)
+{
+	gtk_selection_data_set (selection_data,
+				selection_data->target, 8, (guchar *) string,
+				strlen (string));
+}
+
+static void
+panel_addto_drag_begin_cb (GtkWidget      *canvas,
+			   GdkDragContext *context,
+			   gpointer        data)
+{
+	PanelAddtoEntry         *entry;
+	PanelAddtoCanvasPrivate *priv;
+
+	priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+	entry = priv->selected;
+	gtk_drag_set_icon_pixbuf (context, entry->icon_pixbuf, 0, 0);
+}
+
+static void
+panel_addto_setup_drag (PanelAddtoCanvas     *canvas,
+				     const GtkTargetEntry *target,
+				     const char           *text)
+{
+	if (!text || panel_lockdown_get_locked_down ())
+		return;
+
+	
+	gtk_drag_source_set (GTK_WIDGET (canvas),
+			     GDK_BUTTON1_MASK|GDK_BUTTON2_MASK,
+			     target, 1, GDK_ACTION_COPY);
+		
+	g_signal_connect_data (G_OBJECT (canvas), "drag_data_get",
+			       G_CALLBACK (panel_addto_drag_data_get_cb),
+			       g_strdup (text),
+			       (GClosureNotify) g_free,
+			       0 /* connect_flags */);
+	g_signal_connect_after (G_OBJECT (canvas), "drag-begin",
+	                        G_CALLBACK (panel_addto_drag_begin_cb),
+	                        NULL);
+}
+
+static void
+panel_addto_setup_launcher_drag (PanelAddtoCanvas *canvas,
+				 const char  *uri)
+{
+        static GtkTargetEntry target[] = {
+		{ "text/uri-list", 0, 0 }
+	};
+	char *uri_list;
+
+	uri_list = g_strconcat (uri, "\r\n", NULL);
+	panel_addto_setup_drag (canvas, target, uri_list);
+	g_free (uri_list);
+}
+
+static void
+panel_addto_setup_applet_drag (PanelAddtoCanvas *canvas,
+			       const char  *iid)
+{
+	static GtkTargetEntry target[] = {
+		{ "application/x-panel-applet-iid", 0, 0 }
+	};
+
+	panel_addto_setup_drag (canvas, target, iid);
+}
+
+
+
+static void
+panel_addto_setup_internal_applet_drag (PanelAddtoCanvas *canvas,
+					const char  *applet_type)
+{
+	static GtkTargetEntry target[] = {
+		{ "application/x-panel-applet-internal", 0, 0 }
+	};
+
+	panel_addto_setup_drag (canvas, target, applet_type);
+}
+
+static void
+panel_addto_selection_changed (PanelAddtoCanvas *canvas,
+			       const gchar *status_display,
+			       PanelAddtoDialog *dialog)
+{
+	PanelAddtoItemInfo      *data;
+	PanelAddtoCanvasPrivate *priv;
+
+	priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+	data = priv->selected ? priv->selected->item_info : NULL;
+
+
+	if ((!priv->selected) || (!data)) {
+		gtk_widget_set_sensitive (GTK_WIDGET (dialog->add_button), FALSE);
+		return;
+	}
+
+	gtk_widget_set_sensitive (GTK_WIDGET (dialog->add_button), TRUE);
+
+	if (dialog->statuslabel)
+		gtk_label_set_text (GTK_LABEL (dialog->statuslabel), priv->selected->comment);
+
+	if (data->type == PANEL_ADDTO_LAUNCHER_MENU) {
+		gtk_button_set_label (GTK_BUTTON (dialog->add_button),
+				      GTK_STOCK_GO_FORWARD);
+	} else {
+		gtk_button_set_label (GTK_BUTTON (dialog->add_button),
+				      GTK_STOCK_ADD);
+	}
+	gtk_button_set_use_stock (GTK_BUTTON (dialog->add_button),
+				  TRUE);
+
+}
+
+static void
+select_entry (PanelAddtoCanvas *canvas, PanelAddtoEntry *entry)
+{
+	PanelAddtoDialog        *dialog;
+	PanelAddtoCanvasPrivate *priv;
+	EntryInfo *ei = NULL;
+	GtkAdjustment *pos;
+	double affine[6];
+	PanelAddtoEntry *selected;
+
+	dialog = entry->dialog;
+	priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+	selected = priv->selected;
+
+	if (selected == entry)
+		return;
+
+	if (selected && selected->user_data)
+		((EntryInfo *) selected->user_data)->selected = FALSE;
+	setup_entry (canvas, selected);
+
+	priv->selected = selected = entry;
+
+	if (selected && selected->user_data)
+		((EntryInfo *) selected->user_data)->selected = TRUE;
+	setup_entry (canvas, selected);
+
+	g_signal_emit (canvas, panel_addto_canvas_signals [SELECTION_CHANGED], 0,
+		       (entry) ? entry->comment : NULL);
+
+	if (!entry)
+		return;
+
+	ei = entry->user_data;
+	gnome_canvas_item_i2c_affine (GNOME_CANVAS_ITEM (ei->group), affine);
+	pos = gtk_layout_get_vadjustment (GTK_LAYOUT (ei->cover->canvas));
+
+	if (affine[5] < pos->value)
+		gtk_adjustment_set_value (pos, MAX (affine[5] - PAD, 0));
+	else if ((affine[5] + priv->max_item_height) > (pos->value+pos->page_size))
+		gtk_adjustment_set_value (pos, MAX (MIN (affine[5] + priv->max_item_height + PAD, pos->upper) - pos->page_size, 0));
+}
+
+static gboolean
+cover_event (GnomeCanvasItem *item, GdkEvent *event, PanelAddtoEntry *entry)
+{
+	EntryInfo               *ei = entry->user_data;
+	PanelAddtoCanvas        *canvas = ei->canvas;
+	PanelAddtoItemInfo      *data;
+	PanelAddtoDialog        *dialog = entry->dialog;
+	char                    *iid;
+
+	data = entry->item_info;
+
+	switch (event->type) {
+	case GDK_ENTER_NOTIFY:
+		ei->highlighted = TRUE;
+		setup_entry (canvas, entry); /* highlight even if it is already selected */
+
+		/* only allow dragging applets if we can add applets */
+		if (panel_profile_id_lists_are_writable ()) {
+			switch (data->type) {
+			case PANEL_ADDTO_LAUNCHER:
+				panel_addto_setup_launcher_drag (PANEL_ADDTO_CANVAS (dialog->canvas),
+								 data->launcher_path);
+				break;
+			case PANEL_ADDTO_APPLET:
+				panel_addto_setup_applet_drag (PANEL_ADDTO_CANVAS (dialog->canvas),
+							       data->iid);
+				break;
+			case PANEL_ADDTO_LAUNCHER_MENU:
+				break;
+			case PANEL_ADDTO_MENU:
+				/* build the iid for menus other than the main menu */
+				if (data->iid == NULL) {
+					iid = g_strdup_printf ("MENU:%s/%s",
+							       data->menu_filename,
+							       data->menu_path);
+				} else {
+					iid = g_strdup (data->iid);
+				}
+				panel_addto_setup_internal_applet_drag (PANEL_ADDTO_CANVAS (dialog->canvas),
+									iid);
+				g_free (iid);
+				break;
+			default:
+				panel_addto_setup_internal_applet_drag (PANEL_ADDTO_CANVAS (dialog->canvas),
+									data->iid);
+				break;
+			}
+		}
+		
+		return TRUE;
+	case GDK_LEAVE_NOTIFY:
+		ei->highlighted = FALSE;
+		setup_entry (canvas, entry);
+		return TRUE;
+	case GDK_BUTTON_PRESS:
+		select_entry (canvas, entry);
+		gtk_widget_grab_focus (GTK_WIDGET (canvas));
+		return TRUE;
+	case GDK_2BUTTON_PRESS:
+		if (event->button.button == 1)
+			activate_entry (entry);
+		return TRUE;
+	default:
+		return FALSE;
+	}
+}
+
+static void
+panel_addto_select_first_entry (PanelAddtoCanvas *canvas)
+{
+	PanelAddtoCategory      *category;
+	PanelAddtoEntry         *entry;
+	PanelAddtoCanvasPrivate *priv;
+	EntryInfo               *ei;
+
+	priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+
+	category = g_slist_nth_data (priv->info->categories, 0);
+	entry = g_slist_nth_data (category->entries, 0);
+	ei = entry->user_data;
+	if (!ei->visible) {
+		panel_addto_select_east_entry (ei, canvas);
+		return;
+	}
+	select_entry (canvas, entry);
+}
+
+static gint
+panel_addto_count_visible_entries (PanelAddtoCategory *category)
+{
+	GSList          *l;
+	PanelAddtoEntry *entry;
+	EntryInfo       *ei;
+	gint n_visible_entries = 0;
+
+	for (l = category->entries; l; l = l->next) {
+		entry = l->data;
+		ei = entry->user_data;
+		if (ei->visible)
+			n_visible_entries++;
+	}
+	return n_visible_entries;
+}
+
+static gint
+panel_addto_get_rank_of_nth_visible_entry (PanelAddtoCategory *category, gint n)
+{
+	GSList          *l;
+	PanelAddtoEntry *entry;
+	EntryInfo       *ei;
+	gint             seen_visible_entries = 0;
+	gint             seen_entries = 0;
+	gint             farthest_visible_entry = 0;
+
+	l = category->entries;
+
+	while (seen_visible_entries < n) {
+		if (!l) break;
+		seen_entries++;
+		entry = l->data;
+		ei = entry->user_data;
+		if (ei->visible) {
+			seen_visible_entries++;
+			farthest_visible_entry = seen_entries;
+		}
+		l = l->next;
+	}
+	
+	return (farthest_visible_entry - 1);
+}
+
+static gint
+panel_addto_how_many_visible_entries_before_me (PanelAddtoCategory *category, gint rank)
+{
+	GSList          *l;
+	PanelAddtoEntry *entry;
+	EntryInfo       *ei;
+	gint             seen_entries = 0;
+	gint             seen_visible_entries = 0;
+
+	l = category->entries;
+	while (seen_entries < rank) {
+		entry = l->data;
+		ei = entry->user_data;
+		if (ei->visible)
+			seen_visible_entries++;
+		l = l->next;
+		seen_entries++;
+	}
+	return seen_visible_entries;
+}
+
+static void
+panel_addto_select_east_entry (EntryInfo *ei, PanelAddtoCanvas *canvas)
+{
+	gint                     n_category, n_entry;
+	gint                     n_categories;
+	PanelAddtoEntry         *entry;
+	PanelAddtoCategory      *category;
+	PanelAddtoCanvasPrivate *priv;
+	
+	priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+	
+	n_entry = 0;
+	n_category = 0;
+	n_categories = priv->info->n_categories;
+	
+	if (ei) {
+		n_category = ei->n_category;
+		category = g_slist_nth_data (priv->info->categories, n_category);
+		if (ei->n_entry == category->n_entries - 1) {
+			if (n_category == priv->info->n_categories - 1)
+				return;
+			category = g_slist_nth_data (priv->info->categories, ei->n_category + 1);
+			entry = g_slist_nth_data (category->entries, 0);
+			ei = entry->user_data;
+			if (!ei->visible) {
+				panel_addto_select_east_entry (ei, canvas);
+				return;
+			}
+		}
+		else {
+			entry = g_slist_nth_data (category->entries, ei->n_entry + 1);
+			ei = entry->user_data;
+			if (!ei->visible) {
+				panel_addto_select_east_entry (ei, canvas);
+				return;
+			}			
+		}
+		select_entry (canvas, entry);
+	} else
+		panel_addto_select_first_entry (canvas);
+}
+
+static void
+panel_addto_select_west_entry (EntryInfo *ei, PanelAddtoCanvas *canvas)
+{
+	gint                     n_category, n_entry;
+	gint                     n_categories;
+	PanelAddtoEntry         *entry;
+	PanelAddtoCategory      *category;
+	PanelAddtoCanvasPrivate *priv;
+	
+	priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+	
+	n_entry = 0;
+	n_category = 0;
+	n_categories = priv->info->n_categories;
+	
+	if (ei) {
+		n_category = ei->n_category;
+		category = g_slist_nth_data (priv->info->categories, n_category);
+		if (ei->n_entry == 0) {
+			if (n_category == 0)
+				return;
+			category = g_slist_nth_data (priv->info->categories, ei->n_category - 1);
+			entry = g_slist_nth_data (category->entries, category->n_entries - 1);
+			ei = entry->user_data;
+			if (!ei->visible) {
+				panel_addto_select_west_entry (ei, canvas);
+				return;
+			}
+		} else {
+			entry = g_slist_nth_data (category->entries, ei->n_entry - 1);
+			ei = entry->user_data;
+			if (!ei->visible) {
+				panel_addto_select_west_entry (ei, canvas);
+				return;
+			}
+		}
+		select_entry (canvas, entry);
+	} else
+		panel_addto_select_first_entry (canvas);
+}
+
+static void
+panel_addto_select_north_entry (EntryInfo *ei, PanelAddtoCanvas *canvas)
+{
+	gint                     n_category = 0;
+	gint                     n_categories;
+	gint                     n_visible_entries = 0;
+	gint                     n_visible_entries_before_me = 0;
+	PanelAddtoEntry         *entry;
+	PanelAddtoCategory      *category;
+	PanelAddtoCanvasPrivate *priv;
+	CategoryInfo            *catinfo;
+	
+	priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+	
+	n_categories = priv->info->n_categories;
+	
+	if (ei) {
+		n_category = ei->n_category;
+		category = g_slist_nth_data (priv->info->categories, n_category);
+		n_visible_entries_before_me =
+				panel_addto_how_many_visible_entries_before_me (category, ei->n_entry);
+		if (n_visible_entries_before_me + 1 - priv->items_per_row <= 0) {
+			if (n_category == 0) {
+				panel_addto_select_first_entry (canvas);
+				return;
+			}
+			n_category--;
+			category = g_slist_nth_data (priv->info->categories, n_category);
+			catinfo = category->user_data;
+			if (!catinfo->visible) {
+				while (!catinfo->visible) {
+					category = g_slist_nth_data (priv->info->categories, --n_category);
+					if (!category)
+						return;
+					catinfo = category->user_data;
+					if (!catinfo)
+						return;
+				}
+			}
+			n_visible_entries = panel_addto_count_visible_entries (category);
+			entry = g_slist_nth_data (category->entries, 
+						  panel_addto_get_rank_of_nth_visible_entry 
+						  (category,
+						   ((n_visible_entries - 1) / priv->items_per_row) * priv->items_per_row
+						   + ((n_visible_entries_before_me + 1) % priv->items_per_row)));
+			if (!entry)
+				entry = g_slist_nth_data (category->entries, n_visible_entries - 1);
+			ei = entry->user_data;
+			if (!ei->visible) {
+				panel_addto_select_east_entry (ei, canvas);
+				return;
+			}
+		} else {
+			entry = g_slist_nth_data (category->entries, ei->n_entry - priv->items_per_row);
+			ei = entry->user_data;
+			if (!ei->visible) {
+				panel_addto_select_east_entry (ei, canvas);
+				return;
+			}
+		}
+		select_entry (canvas, entry);
+	} else
+		panel_addto_select_first_entry (canvas);
+}
+
+static void
+panel_addto_select_south_entry (EntryInfo *ei, PanelAddtoCanvas *canvas)
+{
+	gint                     n_category = 0;
+	gint                     n_categories;
+	gint                     n_visible_entries = 0;
+	gint                     n_visible_entries_before_me = 0;
+	PanelAddtoEntry         *entry;
+	PanelAddtoCategory      *category;
+	PanelAddtoCanvasPrivate *priv;
+	CategoryInfo            *catinfo;
+	
+	priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+	
+	n_categories = priv->info->n_categories;
+
+	if (ei) {
+		n_category = ei->n_category;
+		category = g_slist_nth_data (priv->info->categories, n_category);
+		n_visible_entries_before_me =
+				panel_addto_how_many_visible_entries_before_me (category, ei->n_entry);
+		n_visible_entries = panel_addto_count_visible_entries (category);
+		if (n_visible_entries_before_me + 1 + priv->items_per_row > n_visible_entries - 1) {
+			if (n_visible_entries_before_me + 1 
+			    <= ((n_visible_entries - 1) / priv->items_per_row) * priv->items_per_row) {
+				entry = g_slist_nth_data (category->entries, n_visible_entries - 1);
+			} else {
+				if (n_category == priv->info->n_categories - 1)
+					return;
+				n_category++;
+				category = g_slist_nth_data (priv->info->categories, n_category);
+				catinfo = category->user_data;
+				n_visible_entries = panel_addto_count_visible_entries (category);
+				entry = g_slist_nth_data (category->entries, ei->n_entry % priv->items_per_row);
+				if (!catinfo->visible) {
+					while (!catinfo->visible) {
+						category = g_slist_nth_data (priv->info->categories, ++n_category);
+						if (!category)
+							return;
+						catinfo = category->user_data;
+						if (!catinfo)
+							return;
+					}
+				}
+				n_visible_entries = panel_addto_count_visible_entries (category);
+				entry = g_slist_nth_data (category->entries, 
+							  panel_addto_get_rank_of_nth_visible_entry 
+							  (category,
+							   (n_visible_entries_before_me + 1) % priv->items_per_row));
+				
+				if (!entry)
+					entry = g_slist_nth_data (category->entries, n_visible_entries - 1);
+			}
+			ei = entry->user_data;
+			if (!ei->visible) {
+				panel_addto_select_east_entry (ei, canvas);
+				return;
+			}			
+		} else {
+			entry = g_slist_nth_data (category->entries, ei->n_entry + priv->items_per_row);
+			ei = entry->user_data;
+			if (!ei->visible) {
+				panel_addto_select_east_entry (ei, canvas);
+				return;
+			}
+		}
+		select_entry (canvas, entry);
+	} else
+		panel_addto_select_first_entry (canvas);
+}
+
+static gboolean
+cb_canvas_event (GnomeCanvasItem *item, GdkEvent *event, PanelAddtoDialog *dialog)
+{
+	PanelAddtoCanvas        *canvas = (PanelAddtoCanvas *) dialog->canvas;
+	PanelAddtoCanvasPrivate *priv;
+	PanelAddtoCategory      *current_category;
+	EntryInfo               *ei = NULL;
+	gint                     n_category, n_entry;
+	gint                     n_categories, n_entries;
+
+	priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+	
+	if (event->type == GDK_BUTTON_PRESS) {
+		gtk_drag_source_unset (GTK_WIDGET (canvas));
+		select_entry (canvas, NULL);
+		gtk_widget_grab_focus (GTK_WIDGET (dialog->canvas));
+		return TRUE;
+	}
+
+	if (event->type != GDK_KEY_PRESS)
+		return FALSE;
+
+	n_entry = 0;
+	n_category = 0;
+	n_categories = priv->info->n_categories;
+
+	if (priv->selected) {
+		ei = priv->selected->user_data;
+		current_category = g_slist_nth_data (priv->info->categories, ei->n_category);
+		n_entries = current_category->n_entries;
+	}
+
+	switch (event->key.keyval) {
+	case GDK_KP_Right:
+	case GDK_Right:
+		if (priv->rtl)
+			panel_addto_select_west_entry (ei, canvas);
+		else
+			panel_addto_select_east_entry (ei, canvas);
+		return TRUE;
+	case GDK_KP_Left:
+	case GDK_Left:
+		if (priv->rtl)
+			panel_addto_select_east_entry (ei, canvas);
+		else
+			panel_addto_select_west_entry (ei, canvas);
+		return TRUE;
+	case GDK_KP_Down:
+	case GDK_Down:
+		panel_addto_select_south_entry (ei, canvas);
+		return TRUE;
+	case GDK_KP_Up:
+	case GDK_Up:
+		panel_addto_select_north_entry (ei, canvas);
+		return TRUE;
+	case GDK_Tab:
+	case GDK_KP_Tab:
+	case GDK_ISO_Left_Tab:
+		gtk_widget_grab_focus (dialog->search_entry);
+		break;
+	case GDK_Return:
+	case GDK_KP_Enter:
+		if (priv->selected)
+			activate_entry (priv->selected);
+
+		return TRUE;
+		break;
+	case GDK_Escape:
+		panel_addto_dialog_response (dialog->addto_dialog,
+					     GTK_RESPONSE_CANCEL,
+					     dialog);
+		return TRUE;
+	default:
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+
+static void
+calculate_item_width (PanelAddtoCanvas *canvas, EntryInfo *ei)
+{
+	PanelAddtoCanvasPrivate *priv;
+	PangoLayout *layout;
+	PangoRectangle rectangle;
+
+	priv   = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+	layout = GNOME_CANVAS_TEXT (ei->text)->layout;
+
+	pango_layout_set_wrap (layout, PANGO_WRAP_WORD_CHAR);
+	pango_layout_set_width (layout, -1);
+	pango_layout_get_pixel_extents (layout, NULL, &rectangle);
+
+	/* If its too big wrap at the max and regen to find the layout */
+	if (rectangle.width > MAX_ITEM_WIDTH) {
+		pango_layout_set_width (layout, MAX_ITEM_WIDTH * PANGO_SCALE);
+		pango_layout_get_pixel_extents (layout, NULL, &rectangle);
+		rectangle.width = MAX_ITEM_WIDTH;
+	}
+
+	ei->text_height = rectangle.height;
+
+	priv->max_item_width = MAX (priv->max_item_width, rectangle.width);
+}
+
+static void
+calculate_item_height (PanelAddtoCanvas *canvas, EntryInfo *ei)
+{
+	PanelAddtoCanvasPrivate *priv;
+	gint item_height;
+
+	priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+
+	if (ei->pixbuf)
+		priv->max_icon_height = MAX (priv->max_icon_height, ei->icon_height);
+
+	item_height = ei->icon_height + ei->text_height;
+	priv->max_item_height = MAX (priv->max_item_height, item_height);
+}
+
+static void
+calculate_sizes (PanelAddtoCanvas *canvas)
+{
+	GSList                  *l, *m;
+	PanelAddtoCanvasPrivate *priv;
+	PanelAddtoCategory      *current_category;
+	PanelAddtoEntry         *current_entry;
+
+	priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+	priv->max_item_height = 0;
+	priv->max_icon_height = 0;
+	priv->max_item_width  = 0;
+
+	for (l = priv->info->categories; l; l = l->next) {
+		current_category = l->data;
+		for (m = current_category->entries; m; m = m->next) {
+			current_entry = m->data;
+			EntryInfo *ei = current_entry->user_data;
+			calculate_item_width  (canvas, ei);
+			calculate_item_height (canvas, ei);
+		}
+	}
+}
+
+static void
+gnome_canvas_item_move_absolute (GnomeCanvasItem *item, double dx, double dy)
+{
+	double translate[6];
+
+	g_return_if_fail (item != NULL);
+	g_return_if_fail (GNOME_IS_CANVAS_ITEM (item));
+
+	art_affine_translate (translate, dx, dy);
+
+	gnome_canvas_item_affine_absolute (item, translate);
+}
+
+static guchar
+lighten_component (guchar cur_value)
+{
+	int new_value = cur_value;
+	new_value += 24 + (new_value >> 3);
+	if (new_value > 255) {
+		new_value = 255;
+	}
+	return (guchar) new_value;
+}
+
+static GdkPixbuf *
+create_spotlight_pixbuf (GdkPixbuf* src)
+{
+	GdkPixbuf *dest;
+	int i, j;
+	int width, height, has_alpha, src_row_stride, dst_row_stride;
+	guchar *target_pixels, *original_pixels;
+	guchar *pixsrc, *pixdest;
+
+	g_return_val_if_fail (gdk_pixbuf_get_colorspace (src) == GDK_COLORSPACE_RGB, NULL);
+	g_return_val_if_fail ((!gdk_pixbuf_get_has_alpha (src)
+			       && gdk_pixbuf_get_n_channels (src) == 3)
+			      || (gdk_pixbuf_get_has_alpha (src)
+				  && gdk_pixbuf_get_n_channels (src) == 4), NULL);
+	g_return_val_if_fail (gdk_pixbuf_get_bits_per_sample (src) == 8, NULL);
+
+	dest = gdk_pixbuf_copy (src);
+
+	has_alpha = gdk_pixbuf_get_has_alpha (src);
+	width = gdk_pixbuf_get_width (src);
+	height = gdk_pixbuf_get_height (src);
+	dst_row_stride = gdk_pixbuf_get_rowstride (dest);
+	src_row_stride = gdk_pixbuf_get_rowstride (src);
+	target_pixels = gdk_pixbuf_get_pixels (dest);
+	original_pixels = gdk_pixbuf_get_pixels (src);
+
+	for (i = 0; i < height; i++) {
+		pixdest = target_pixels + i * dst_row_stride;
+		pixsrc = original_pixels + i * src_row_stride;
+		for (j = 0; j < width; j++) {
+			*pixdest++ = lighten_component (*pixsrc++);
+			*pixdest++ = lighten_component (*pixsrc++);
+			*pixdest++ = lighten_component (*pixsrc++);
+			if (has_alpha) {
+				*pixdest++ = *pixsrc++;
+			}
+		}
+	}
+
+	return dest;
+}
+
+static void
+build_canvas (PanelAddtoCanvas *canvas)
+{
+	GSList                  *l, *m;
+	EntryInfo               *ei;
+	PanelAddtoDialog        *dialog;
+	PanelAddtoCategory      *current_category = NULL;
+	PanelAddtoInformation   *current_info     = NULL;
+	PanelAddtoEntry         *current_entry    = NULL;
+	PanelAddtoCanvasPrivate *priv;
+	GnomeCanvas             *gcanvas;
+	GnomeCanvasGroup        *hidden_group;
+	int i, j, index;
+	
+	priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+	gcanvas = GNOME_CANVAS (canvas);
+	current_category = priv->info->categories->data;
+	current_entry = current_category->entries->data;
+	dialog = current_entry->dialog;
+	index = 0;
+
+	priv->under_cover = gnome_canvas_item_new (gnome_canvas_root (gcanvas),
+						   panel_addto_event_box_get_type(),
+						   NULL);
+
+	current_info = priv->info;
+	gnome_canvas_item_grab_focus (GNOME_CANVAS_ITEM (gnome_canvas_root (gcanvas)));
+	g_signal_connect (gnome_canvas_root (gcanvas), "event",
+			  G_CALLBACK (cb_canvas_event), dialog);
+
+	hidden_group =	GNOME_CANVAS_GROUP (gnome_canvas_item_new (gnome_canvas_root (gcanvas),
+								   gnome_canvas_group_get_type (),
+								   NULL));
+	for (l = priv->info->categories, i = 0; l; l = l->next, i++) {
+
+		CategoryInfo *catinfo;
+		current_category = l->data;
+
+		if (current_category->user_data == NULL)
+			current_category->user_data = g_new (CategoryInfo, 1);
+
+		catinfo = current_category->user_data;
+		catinfo->group = NULL;
+		catinfo->title = NULL;
+		catinfo->line = NULL;
+
+		catinfo->group =
+			GNOME_CANVAS_GROUP (gnome_canvas_item_new (gnome_canvas_root (gcanvas),
+								   gnome_canvas_group_get_type (),
+								   NULL));
+		gnome_canvas_item_move_absolute (GNOME_CANVAS_ITEM (catinfo->group), 0, BORDERS);
+
+		catinfo->line = gnome_canvas_item_new (catinfo->group,
+			gnome_canvas_rect_get_type (),
+			"x2", (double) priv->max_width - 2 * BORDERS,
+			"y2", (double) LINE_HEIGHT,
+			NULL);
+
+		catinfo->title = NULL;
+
+		if (current_category && (priv->info->n_categories != 1)) {
+			char *label = g_strdup_printf ("<span weight=\"bold\">%s</span>", current_category->title);
+			catinfo->title = gnome_canvas_item_new (catinfo->group,
+				gnome_canvas_text_get_type (),
+				"text", current_category->title,
+				"markup", label,
+				"anchor", GTK_ANCHOR_NW,
+				NULL);
+			g_free (label);
+		}
+
+		for (m = current_category->entries, j = 0; m; m = m->next, j++) {
+			current_entry = m->data;
+
+			if (current_entry->user_data == NULL)
+				current_entry->user_data = g_new0 (EntryInfo, 1);
+
+			ei = current_entry->user_data;
+
+			ei->canvas = canvas;
+			ei->group  = GNOME_CANVAS_GROUP (
+				gnome_canvas_item_new (catinfo->group,
+				gnome_canvas_group_get_type (),
+				NULL));
+			ei->selection = gnome_canvas_item_new (
+				ei->group,
+				PANEL_ADDTO_TYPE_ROUNDED_RECT,
+				NULL);
+
+			if (current_entry->title) {
+				ei->text = gnome_canvas_item_new (ei->group,
+					gnome_canvas_text_get_type (),
+					"anchor", GTK_ANCHOR_NW,
+					"justification", GTK_JUSTIFY_CENTER,
+					"clip",	  TRUE,
+					NULL);
+				pango_layout_set_alignment (GNOME_CANVAS_TEXT (ei->text)->layout,
+							    PANGO_ALIGN_CENTER);
+				pango_layout_set_justify (GNOME_CANVAS_TEXT (ei->text)->layout,
+							  FALSE);
+				g_object_set (ei->text,
+					      "text", current_entry->title,
+					      NULL);
+			} else
+				ei->text = NULL;
+
+			if (current_entry->icon_pixbuf) {
+				GdkPixbuf *pixbuf = current_entry->icon_pixbuf;
+				GdkPixbuf *highlight_pixbuf =
+					create_spotlight_pixbuf (pixbuf);
+
+				ei->icon_height = gdk_pixbuf_get_height (pixbuf);
+				ei->icon_width  = gdk_pixbuf_get_width (pixbuf);
+				ei->pixbuf = gnome_canvas_item_new (ei->group,
+					gnome_canvas_pixbuf_get_type (),
+					"pixbuf", pixbuf,
+					NULL);
+				g_object_unref (pixbuf);
+				ei->highlight_pixbuf = gnome_canvas_item_new (ei->group,
+					gnome_canvas_pixbuf_get_type (),
+					"pixbuf", highlight_pixbuf,
+					NULL);
+				g_object_unref (highlight_pixbuf);
+			} else {
+				ei->pixbuf = NULL;
+				ei->highlight_pixbuf = NULL;
+			}
+
+			ei->cover = gnome_canvas_item_new (ei->group,
+							   panel_addto_event_box_get_type(),
+							   NULL);
+			calculate_item_width  (canvas, ei);
+			calculate_item_height (canvas, ei);
+			
+			ei->n_category = i;
+			ei->n_entry = j;
+			ei->index = index;
+
+			setup_entry (canvas, current_entry);
+
+			g_signal_connect (ei->cover, "event",
+					  G_CALLBACK (cover_event),
+					  current_entry);
+			index++;
+		}
+	}
+
+	dialog = current_entry->dialog;
+	
+	g_signal_connect (G_OBJECT (canvas), "selection-changed",
+	                  G_CALLBACK (panel_addto_selection_changed), current_entry->dialog);
+}
+
+
+static const char *
+panel_addto_utf8_casestrstr (const char *haystack, const char *needle)
+{
+	
+	if (!haystack)
+		return NULL;
+	
+	haystack = g_utf8_strdown (haystack, -1);
+	needle   = g_utf8_strdown (needle, -1);
+	
+	const char *s;
+	gsize       i;
+	gsize       haystack_len = g_utf8_strlen (haystack, -1);
+	gsize       needle_len = g_utf8_strlen (needle, -1);
+	int         needle_size = strlen (needle);
+	
+	if (needle_len > haystack_len)
+		return NULL;
+	
+	s = haystack;
+	for (i = 0; i <= haystack_len - needle_len; i++) {
+		if (strncmp (s, needle, needle_size) == 0)
+			return s;
+		s = g_utf8_next_char (s);
+	}
+	
+	return NULL;
+}
+
+void
+panel_addto_relayout_for_search (GtkWidget *search_entry, PanelAddtoDialog *dialog)
+{
+	gchar                   *search_text;
+	PanelAddtoCanvasPrivate *priv;
+
+	search_text = g_malloc (strlen ((gchar*) gtk_entry_get_text (GTK_ENTRY (search_entry))) + 1);
+	g_stpcpy (search_text, gtk_entry_get_text (GTK_ENTRY (search_entry)));
+	g_strchomp (search_text);
+	if (dialog->canvas) {
+		priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (dialog->canvas);
+		priv->search_text = search_text;
+		gtk_widget_queue_resize (GTK_WIDGET (dialog->canvas));
+	}
+}
+
+void
+panel_addto_activate_from_searchbar (GtkWidget *search_entry, PanelAddtoDialog *dialog)
+{
+	PanelAddtoCanvasPrivate *priv;
+
+	priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (dialog->canvas);
+	if (priv->selected)
+		activate_entry (priv->selected);
+}
+
+/* If we can't find the search query in the applet's name, in the applet's
+ * description, nor in the applet's category, then the applet has to be hidden.
+ */
+
+static gboolean
+panel_addto_entry_must_be_hidden (PanelAddtoEntry *entry, const gchar **search_terms)
+{
+	gint i;
+	gint nb_search_terms = 0, nb_found = 0;
+	gboolean search_is_null = TRUE;
+	
+	for (i = 0; search_terms[i] != NULL; i++) {
+		nb_search_terms ++;
+		search_is_null = FALSE;
+		if (
+		    (entry->title 
+		     && panel_addto_utf8_casestrstr (g_locale_to_utf8 (entry->title, -1, NULL, NULL, NULL),
+						     g_locale_to_utf8 (search_terms[i], -1, NULL, NULL, NULL)))
+		    || (entry->comment 
+			&& panel_addto_utf8_casestrstr (g_locale_to_utf8 (entry->comment, -1, NULL, NULL, NULL),
+							g_locale_to_utf8 (search_terms[i], -1, NULL, NULL, NULL)))
+		    || (entry->category->title 
+			&& panel_addto_utf8_casestrstr (g_locale_to_utf8 (entry->category->title, -1, NULL, NULL, NULL),
+							g_locale_to_utf8 (search_terms[i], -1, NULL, NULL, NULL))))
+			nb_found++;
+	}
+
+	if (search_is_null || nb_found == nb_search_terms)
+		return FALSE;
+
+	return TRUE;
+}
+
+/* A category canvas item contains all the elements
+ * for the category, as well as the title and a separator
+ */
+static void
+relayout_category (PanelAddtoCanvas *canvas, CategoryInfo *catinfo,
+		   gint vert_pos, gint *category_vert_pos)
+{
+	PanelAddtoCanvasPrivate *priv;
+
+	priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+	gnome_canvas_item_move_absolute (GNOME_CANVAS_ITEM (catinfo->group),
+					 0, vert_pos);
+
+	if (catinfo->line) {
+		gnome_canvas_item_move_absolute (catinfo->line, BORDERS, ABOVE_LINE_SPACING);
+
+		gnome_canvas_item_set (catinfo->line,
+				       "x2", (double) priv->max_width - 2 * BORDERS,
+				       "y2", (double) LINE_HEIGHT,
+				       NULL);
+	}
+
+	if (catinfo->title) {
+		double text_height, text_width;
+
+		g_object_get (catinfo->title,
+			      "text_height", &text_height,
+			      "text_width",  &text_width,
+			      NULL);
+
+		*category_vert_pos += text_height; /* move it down 1 line */
+		gnome_canvas_item_move_absolute (catinfo->title,
+						 (priv->rtl) ? priv->max_width - BORDERS - text_width : BORDERS,
+						 *category_vert_pos);
+		*category_vert_pos += text_height + text_height/2 + UNDER_TITLE_SPACING;
+	}
+}
+
+static void
+relayout_item (PanelAddtoCanvas *canvas, EntryInfo *ei,
+	       gint category_horiz_pos, gint category_vert_pos)
+{
+	PanelAddtoCanvasPrivate *priv;
+
+	priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+
+	gnome_canvas_item_move_absolute (GNOME_CANVAS_ITEM (ei->group),
+					 category_horiz_pos,
+					 category_vert_pos);
+
+	gnome_canvas_item_set (ei->selection,
+			       "x2", (double) priv->max_item_width + 2 * PAD,
+			       "y2", (double) ei->text_height + 1, /* expand it down slightly */
+			       NULL);
+
+	gnome_canvas_item_move_absolute (ei->selection, -PAD, priv->max_icon_height);
+
+	if (ei->text) {
+		/* canvas asks layout for its extent, layout gives real
+		 * size, not fixed width and drawing gets confused.
+		 */
+		gnome_canvas_item_set (ei->text,
+				       "clip_width",  (double) priv->max_item_width,
+				       "clip_height", (double) priv->max_item_height,
+				       NULL);
+
+		/* text is centered by pango */
+		pango_layout_set_width (GNOME_CANVAS_TEXT (ei->text)->layout,
+					(gint) priv->max_item_width * PANGO_SCALE);
+
+		gnome_canvas_item_move_absolute (ei->text,
+						 0, priv->max_icon_height);
+	}
+
+	if (ei->pixbuf) {
+		/* manually center the icon */
+		gnome_canvas_item_move_absolute (ei->pixbuf,
+						 priv->max_item_width / 2 - ei->icon_width / 2, 0);
+		gnome_canvas_item_move_absolute (ei->highlight_pixbuf,
+						 priv->max_item_width / 2 - ei->icon_width / 2, 0);
+	}
+
+	/* cover the item */
+	gnome_canvas_item_set (ei->cover,
+			       "x2", (double) priv->max_item_width,
+			       "y2", (double) priv->max_item_height,
+			       NULL);
+}
+
+static void
+relayout_canvas (PanelAddtoCanvas *canvas)
+{
+	gint                    entry;
+	gint                    vert_pos, category_vert_pos, category_horiz_pos;
+	gint                    real_width;
+	PanelAddtoCanvasPrivate *priv;
+	PanelAddtoCategory      *current_category;
+	PanelAddtoEntry         *current_entry;
+	CategoryInfo            *catinfo;
+	EntryInfo               *ei;
+	GSList                  *l, *m;
+	gboolean                 at_least_one_found, first_shown_category, first_shown_entry;
+
+	priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+	real_width = priv->max_width - 2 * BORDERS + ITEMS_SEPARATION;
+	priv->items_per_row = real_width / ((gint) priv->max_item_width + ITEMS_SEPARATION);
+
+	vert_pos = BORDERS;
+
+	const gchar *search_text = priv->search_text;
+	gchar **search_terms;
+	search_terms = search_text ? g_strsplit (search_text, " ", 0) : NULL;
+
+	first_shown_category = TRUE;
+	first_shown_entry    = TRUE;
+
+	for (l = priv->info->categories; l; l = l->next) {
+
+		at_least_one_found = FALSE;
+		category_vert_pos = 0;
+
+		category_horiz_pos = (priv->rtl) ? priv->max_width - (gint) priv->max_item_width - BORDERS : BORDERS;
+
+		current_category = l->data;
+		catinfo  = current_category->user_data;
+
+		relayout_category (canvas, catinfo, vert_pos, &category_vert_pos);
+		category_vert_pos += UNDER_LINE_SPACING;
+
+		for (m = current_category->entries, entry = 0; m; m = m->next, entry++) {
+
+			current_entry = m->data;
+			ei = current_entry->user_data;
+
+			/* we don't want the first item to wrap, it would
+			   be too separated from the section title */
+
+			if (!search_text || !panel_addto_entry_must_be_hidden (current_entry, (const gchar **)search_terms)) {
+				at_least_one_found = TRUE;
+				gnome_canvas_item_show (GNOME_CANVAS_ITEM (ei->group));
+				ei->visible = TRUE;
+				if ((entry > 0) &&
+				    ((priv->items_per_row == 0) ||
+				     (priv->items_per_row > 0 && (entry % priv->items_per_row == 0)))) {
+					
+					category_horiz_pos = (priv->rtl) ?
+						priv->max_width - (gint) priv->max_item_width - BORDERS : BORDERS;
+					category_vert_pos  += (gint) priv->max_item_height + ITEMS_SEPARATION;
+				}
+				
+				relayout_item (canvas, ei, category_horiz_pos, category_vert_pos);
+				
+				if (priv->rtl)
+					category_horiz_pos -= (gint) priv->max_item_width + ITEMS_SEPARATION;
+				else
+					category_horiz_pos += (gint) priv->max_item_width + ITEMS_SEPARATION;
+				
+				/* If the user is actually using the search bar, select
+				 * the first shown entry.
+				 */
+				if (search_text && first_shown_entry) {
+					select_entry (canvas, current_entry);
+					first_shown_entry = FALSE;
+				}
+			} else {
+				gnome_canvas_item_hide (GNOME_CANVAS_ITEM (ei->group));
+				ei->visible = FALSE;
+				entry --;
+			}
+			
+		}
+		if (at_least_one_found) {
+			gnome_canvas_item_show (GNOME_CANVAS_ITEM (catinfo->group));
+			catinfo->visible = TRUE;
+			category_vert_pos += (gint) priv->max_item_height;
+			vert_pos += category_vert_pos + ITEMS_SEPARATION;
+
+			if (first_shown_category) {
+				g_object_set (catinfo->line,
+					      "x2", (double) priv->max_width - 2 * BORDERS,
+					      "y2", (double) 0,
+					      NULL);
+				first_shown_category = FALSE;
+			} else {
+				g_object_set (catinfo->line,
+					      "x2", (double) priv->max_width - 2 * BORDERS,
+					      "y2", (double) LINE_HEIGHT,
+					      NULL);
+			}
+			
+		} else {
+			gnome_canvas_item_hide (GNOME_CANVAS_ITEM (catinfo->group));
+			catinfo->visible = FALSE;
+		}
+	}
+	
+	/* substract the last ITEMS_SEPARATION to
+	   adjust the canvas size a bit more */
+	vert_pos -= ITEMS_SEPARATION;
+
+	priv->height = MAX (vert_pos, priv->min_height);
+	priv->width  = priv->max_width;
+}
+
+
+static void
+set_style (PanelAddtoCanvas *canvas, gboolean font_changed)
+{
+	GSList                  *l, *m;
+	PanelAddtoCategory      *current_category;
+	PanelAddtoEntry         *current_entry;
+	PanelAddtoCanvasPrivate *priv;
+	GtkWidget               *widget = GTK_WIDGET (canvas);
+
+
+	if (!GTK_WIDGET_REALIZED (widget))
+		return;
+
+	priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+
+	for (l = priv->info->categories; l; l = l->next) {
+		current_category = l->data;
+		CategoryInfo *catinfo = current_category->user_data;
+
+		if (catinfo->line) {
+			g_object_set (catinfo->line,
+				      "fill_color_gdk", &widget->style->text_aa[GTK_STATE_NORMAL],
+				      NULL);
+		}
+		if (catinfo->title) {
+			g_object_set (catinfo->title,
+				      "fill_color_gdk", &widget->style->text[GTK_STATE_NORMAL],
+				      NULL);
+
+			if (font_changed)
+				g_object_set (catinfo->title,
+					      "font", NULL,
+					      NULL);
+		}
+
+		for (m = current_category->entries; m; m = m->next) {
+			current_entry = m->data;
+			EntryInfo *entryinfo = current_entry->user_data;
+			if (font_changed && entryinfo->text)
+				g_object_set (entryinfo->text,
+					      "font", NULL,
+					      NULL);
+			setup_entry (canvas, current_entry);
+		}
+	}
+
+	if (font_changed) {
+		calculate_sizes (canvas);
+		relayout_canvas (canvas);
+	}
+}
+
+
+GtkWidget*
+panel_addto_canvas_new (PanelAddtoInformation *info)
+{
+	
+	return g_object_new (PANEL_ADDTO_TYPE_CANVAS,
+			     "info", info,
+			     NULL);
+}
+
+/* Accessibility support */
+
+static gpointer accessible_parent_class;
+static gpointer accessible_item_parent_class;
+
+enum {
+	ACTION_ACTIVATE,
+	LAST_ACTION
+};
+
+typedef struct {
+	AtkObject parent;
+
+	PanelAddtoEntry *entry;
+	AtkStateSet *state_set;
+
+	guint action_idle_handler;
+} PanelAddtoCanvasItemAccessible;
+
+typedef struct {
+	AtkObjectClass parent_class;
+} PanelAddtoCanvasItemAccessibleClass;
+
+static const gchar *const action_names[] = 
+{
+	"activate",
+	NULL
+};
+
+static const gchar *const action_descriptions[] =
+{
+	"Activate item",
+	NULL
+};
+
+static void
+panel_addto_canvas_item_accessible_get_extents (AtkComponent *component,
+					    gint         *x,
+					    gint         *y,
+					    gint         *width,
+					    gint         *height,
+					    AtkCoordType  coord_type)
+{
+	PanelAddtoCanvasItemAccessible *item;
+	PanelAddtoCanvas *canvas;
+	GnomeCanvasItem *cover;
+	AtkObject *parent_object;
+	gint p_x, p_y;
+
+	item = (PanelAddtoCanvasItemAccessible *) component;
+
+	canvas = ((EntryInfo *) item->entry->user_data)->canvas;
+	parent_object = gtk_widget_get_accessible (GTK_WIDGET (canvas));
+	atk_component_get_position (ATK_COMPONENT (parent_object), &p_x, &p_y, coord_type);
+
+
+	/* the cover pretty much represents the item size */
+
+
+	cover = GNOME_CANVAS_ITEM (((EntryInfo *)item->entry->user_data)->cover);
+
+	*x = p_x + cover->x1;
+	*y = p_y + cover->y1;
+	*width  = cover->x2 - cover->x1;
+	*height = cover->y2 - cover->y1;
+}
+
+static void
+atk_component_item_interface_init (AtkComponentIface *iface)
+{
+	iface->get_extents = panel_addto_canvas_item_accessible_get_extents;
+}
+
+static gboolean
+idle_do_action (gpointer data)
+{
+	PanelAddtoCanvasItemAccessible *item;
+
+	item = (PanelAddtoCanvasItemAccessible *) data;
+
+	item->action_idle_handler = 0;
+	activate_entry (item->entry);
+
+	return FALSE;
+}
+
+
+static gboolean
+panel_addto_canvas_item_accessible_action_do_action (AtkAction *action,
+						 gint       index)
+{
+	PanelAddtoCanvasItemAccessible *item;
+
+	if (index < 0 || index >= LAST_ACTION) 
+		return FALSE;
+
+	item = (PanelAddtoCanvasItemAccessible *) action;
+
+	switch (index) {
+	case ACTION_ACTIVATE:
+		if (!item->action_idle_handler)
+			item->action_idle_handler = g_idle_add (idle_do_action, item);
+		break;
+	default:
+		g_assert_not_reached ();
+		return FALSE;
+	}        
+
+	return TRUE;
+}
+
+static gint
+panel_addto_canvas_item_accessible_action_get_n_actions (AtkAction *action)
+{
+        return LAST_ACTION;
+}
+
+static const gchar *
+panel_addto_canvas_item_accessible_action_get_description (AtkAction *action,
+                                                      gint       index)
+{
+	if (index < 0 || index >= LAST_ACTION) 
+		return NULL;
+
+	return action_descriptions[index];
+}
+
+static const gchar *
+panel_addto_canvas_item_accessible_action_get_name (AtkAction *action,
+                                               gint       index)
+{
+	if (index < 0 || index >= LAST_ACTION) 
+		return NULL;
+
+	return action_names[index];
+}
+
+static void
+atk_action_item_interface_init (AtkActionIface *iface)
+{
+	iface->do_action = panel_addto_canvas_item_accessible_action_do_action;
+	iface->get_n_actions = panel_addto_canvas_item_accessible_action_get_n_actions;
+	iface->get_description = panel_addto_canvas_item_accessible_action_get_description;
+	iface->get_name = panel_addto_canvas_item_accessible_action_get_name;
+}
+
+static gint
+panel_addto_canvas_item_accessible_get_index_in_parent (AtkObject *object)
+{
+	PanelAddtoCanvasItemAccessible *item;
+
+	item = (PanelAddtoCanvasItemAccessible *) object;
+
+	return ((EntryInfo *) item->entry->user_data)->index;
+}
+
+static G_CONST_RETURN gchar*
+panel_addto_canvas_item_accessible_get_name (AtkObject *object)
+{
+	PanelAddtoCanvasItemAccessible *item;
+
+	if (object->name)
+		return object->name;
+	else {
+		item = (PanelAddtoCanvasItemAccessible *) object;
+
+		if (item->entry && item->entry->title)
+			return item->entry->title;
+		else
+			return "Item with no description";
+	}
+}
+
+static AtkObject*
+panel_addto_canvas_item_accessible_get_parent (AtkObject *object)
+{
+	PanelAddtoCanvasItemAccessible *item;
+	PanelAddtoCanvas *canvas;
+
+	item = (PanelAddtoCanvasItemAccessible *) object;
+	canvas = ((EntryInfo *) item->entry->user_data)->canvas;
+
+	return gtk_widget_get_accessible (GTK_WIDGET (canvas));
+}
+
+static AtkStateSet*
+panel_addto_canvas_item_accessible_ref_state_set (AtkObject *object)
+{
+	PanelAddtoCanvasItemAccessible *item;
+	PanelAddtoCanvasPrivate *priv;
+	PanelAddtoCanvas *canvas;
+
+	item   = (PanelAddtoCanvasItemAccessible *) object;
+	canvas = ((EntryInfo *) item->entry->user_data)->canvas;
+	priv   = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+
+	if (item->entry == priv->selected)
+		atk_state_set_add_state (item->state_set, ATK_STATE_FOCUSED);
+	else
+		atk_state_set_remove_state (item->state_set, ATK_STATE_FOCUSED);
+
+	return g_object_ref (item->state_set);
+}
+
+static void
+panel_addto_canvas_item_accessible_class_init (AtkObjectClass *class)
+{
+	GObjectClass *object_class;
+
+	accessible_item_parent_class = g_type_class_peek_parent (class);
+
+	object_class = (GObjectClass *)class;
+
+	class->get_index_in_parent = panel_addto_canvas_item_accessible_get_index_in_parent; 
+	class->get_name = panel_addto_canvas_item_accessible_get_name;
+	class->get_parent = panel_addto_canvas_item_accessible_get_parent; 
+	class->ref_state_set = panel_addto_canvas_item_accessible_ref_state_set;
+}
+
+static void
+panel_addto_canvas_item_accessible_object_init (PanelAddtoCanvasItemAccessible *item)
+{
+	item->state_set = atk_state_set_new ();
+
+	atk_state_set_add_state (item->state_set, ATK_STATE_ENABLED);
+	atk_state_set_add_state (item->state_set, ATK_STATE_FOCUSABLE);
+	atk_state_set_add_state (item->state_set, ATK_STATE_SENSITIVE);
+	atk_state_set_add_state (item->state_set, ATK_STATE_SELECTABLE);
+	atk_state_set_add_state (item->state_set, ATK_STATE_VISIBLE);
+
+	item->action_idle_handler = 0;
+}
+
+static GType
+panel_addto_canvas_item_accessible_get_type (void)
+{
+	static GType type = 0;
+
+	if (type == 0) {
+		static const GTypeInfo info = {
+			sizeof (PanelAddtoCanvasItemAccessibleClass),
+			(GBaseInitFunc) NULL, /* base init */
+			(GBaseFinalizeFunc) NULL, /* base finalize */
+			(GClassInitFunc) panel_addto_canvas_item_accessible_class_init, /* class init */
+			(GClassFinalizeFunc) NULL, /* class finalize */
+			NULL, /* class data */
+			sizeof (PanelAddtoCanvasItemAccessible), /* instance size */
+			0, /* nb preallocs */
+			(GInstanceInitFunc) panel_addto_canvas_item_accessible_object_init, /* instance init */
+			NULL /* value table */
+		};
+
+		static const GInterfaceInfo atk_component_info = {
+			(GInterfaceInitFunc) atk_component_item_interface_init,
+			(GInterfaceFinalizeFunc) NULL,
+			NULL
+		};
+
+		static const GInterfaceInfo atk_action_info = {
+			(GInterfaceInitFunc) atk_action_item_interface_init,
+			(GInterfaceFinalizeFunc) NULL,
+			NULL
+		};
+
+		type = g_type_register_static (ATK_TYPE_OBJECT,
+					       "PanelAddtoCanvasItemAccessible", &info, 0);
+
+		g_type_add_interface_static (type, ATK_TYPE_COMPONENT,
+					     &atk_component_info);
+		g_type_add_interface_static (type, ATK_TYPE_ACTION,
+					     &atk_action_info);
+	}
+
+	return type;
+}
+
+static gint
+panel_addto_canvas_accessible_get_n_children (AtkObject *accessible)
+{
+	GSList                  *l;
+	PanelAddtoCategory      *current_category;
+	PanelAddtoCanvasPrivate *priv;
+	PanelAddtoCanvas        *canvas;
+	GtkWidget               *widget;
+	gint count;
+
+	widget = GTK_ACCESSIBLE (accessible)->widget;
+
+	if (!widget)
+		return 0;
+
+	canvas = PANEL_ADDTO_CANVAS (widget);
+	priv   = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+	count  = 0;
+
+	for (l = priv->info->categories; l; l = l->next) {
+		current_category = l->data;
+		count += current_category->n_entries;
+	}
+
+	return count;
+}
+
+static PanelAddtoEntry*
+panel_addto_canvas_accessible_get_entry (PanelAddtoCanvas *canvas, gint index)
+{
+	GSList                  *l;
+	PanelAddtoCanvasPrivate *priv;
+	PanelAddtoCategory      *current_category;
+	gint count;
+
+	priv  = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+	count = 0;
+	
+	for (l = priv->info->categories; l; l = l->next) {
+		current_category = l->data;
+		if (index >= count &&
+		    index < count + current_category->n_entries) {
+			return g_slist_nth_data (current_category->entries, index - count);
+		} else
+			count += current_category->n_entries;
+	}
+
+	return NULL;
+}
+
+static AtkObject*
+panel_addto_canvas_accessible_ref_child (AtkObject *accessible, gint index)
+{
+	PanelAddtoCanvasItemAccessible *item;
+	PanelAddtoEntry *entry;
+	PanelAddtoCanvasPrivate *priv;
+	PanelAddtoCanvas *canvas;
+	GtkWidget *widget;
+	AtkObject *object;
+
+	widget = GTK_ACCESSIBLE (accessible)->widget;
+
+	if (!widget)
+		return NULL;
+
+	canvas = PANEL_ADDTO_CANVAS (widget);
+	priv   = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+	entry  = panel_addto_canvas_accessible_get_entry (canvas, index);
+
+	if (!entry)
+		return NULL;
+
+	object = g_hash_table_lookup (priv->accessible_children, &index);
+
+	if (!object) {
+		object = g_object_new (panel_addto_canvas_item_accessible_get_type (), NULL);
+		item   = (PanelAddtoCanvasItemAccessible *) object;
+
+		object->role = ATK_ROLE_ICON;
+		item->entry  = entry;
+
+		g_hash_table_insert (priv->accessible_children,
+				     &((EntryInfo *) entry->user_data)->index, object);
+	}
+
+	return g_object_ref (object);
+}
+
+static void
+panel_addto_canvas_accessible_initialize (AtkObject *accessible, gpointer data)
+{
+	if (ATK_OBJECT_CLASS (accessible_parent_class)->initialize)
+		ATK_OBJECT_CLASS (accessible_parent_class)->initialize (accessible, data);
+
+	accessible->role = ATK_ROLE_LAYERED_PANE;
+}
+
+static void
+panel_addto_canvas_accessible_class_init (AtkObjectClass *class)
+{
+	GObjectClass *object_class;
+	GtkAccessibleClass *accessible_class;
+
+	accessible_parent_class = g_type_class_peek_parent (class);
+
+	object_class = (GObjectClass *)class;
+	accessible_class = (GtkAccessibleClass *)class;
+
+	class->get_n_children = panel_addto_canvas_accessible_get_n_children;
+	class->ref_child = panel_addto_canvas_accessible_ref_child;
+	class->initialize = panel_addto_canvas_accessible_initialize;
+}
+
+static gboolean
+panel_addto_canvas_accessible_add_selection (AtkSelection *selection, gint i)
+{
+	PanelAddtoCanvasPrivate *priv;
+	PanelAddtoCanvas *canvas;
+	GtkWidget *widget;
+	PanelAddtoEntry *entry;
+
+	widget = GTK_ACCESSIBLE (selection)->widget;
+
+	if (!widget)
+		return FALSE;
+
+	canvas = PANEL_ADDTO_CANVAS (widget);
+	priv   = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+
+	entry = panel_addto_canvas_accessible_get_entry (canvas, i);
+	select_entry (canvas, entry);
+
+	return TRUE;
+}
+
+static gboolean
+panel_addto_canvas_accessible_clear_selection (AtkSelection *selection)
+{
+	PanelAddtoCanvas *canvas;
+	GtkWidget *widget;
+
+	widget = GTK_ACCESSIBLE (selection)->widget;
+
+	if (!widget)
+		return FALSE;
+
+	canvas = PANEL_ADDTO_CANVAS (widget);
+	select_entry (canvas, NULL);
+
+	return TRUE;
+}
+
+static AtkObject*
+panel_addto_canvas_accessible_ref_selection (AtkSelection *selection, gint i)
+{
+	PanelAddtoCanvasPrivate *priv;
+	PanelAddtoCanvas *canvas;
+	GtkWidget *widget;
+
+	widget = GTK_ACCESSIBLE (selection)->widget;
+
+	if (!widget)
+		return NULL;
+
+	canvas = PANEL_ADDTO_CANVAS (widget);
+	priv   = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+
+	if (priv->selected)
+		return atk_object_ref_accessible_child (gtk_widget_get_accessible (widget),
+							((EntryInfo *)priv->selected->user_data)->index);
+	return NULL;
+}
+
+static gint
+panel_addto_canvas_accessible_get_selection_count (AtkSelection *selection)
+{
+	PanelAddtoCanvasPrivate *priv;
+	PanelAddtoCanvas *canvas;
+	GtkWidget *widget;
+
+	widget = GTK_ACCESSIBLE (selection)->widget;
+
+	if (!widget)
+		return 0;
+
+	canvas = PANEL_ADDTO_CANVAS (widget);
+	priv   = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+
+	return (priv->selected) ? 1 : 0;
+}
+
+static gboolean
+panel_addto_canvas_accessible_is_child_selected (AtkSelection *selection, gint i)
+{
+	PanelAddtoCanvasPrivate *priv;
+	PanelAddtoCanvas *canvas;
+	GtkWidget *widget;
+
+	widget = GTK_ACCESSIBLE (selection)->widget;
+
+	if (!widget)
+		return FALSE;
+
+	canvas = PANEL_ADDTO_CANVAS (widget);
+	priv   = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+
+	return (priv->selected == panel_addto_canvas_accessible_get_entry (canvas, i));
+}
+
+static gboolean
+panel_addto_canvas_accessible_remove_selection (AtkSelection *selection, gint i)
+{
+	/* There can be only one item selected */
+	return panel_addto_canvas_accessible_clear_selection (selection);
+}
+
+static gboolean
+panel_addto_canvas_accessible_select_all_selection (AtkSelection *selection)
+{
+	/* This can't happen */
+	return FALSE;
+}
+
+static void
+panel_addto_canvas_accessible_selection_interface_init (AtkSelectionIface *iface)
+{
+	iface->add_selection = panel_addto_canvas_accessible_add_selection;
+	iface->clear_selection = panel_addto_canvas_accessible_clear_selection;
+	iface->ref_selection = panel_addto_canvas_accessible_ref_selection;
+	iface->get_selection_count = panel_addto_canvas_accessible_get_selection_count;
+	iface->is_child_selected = panel_addto_canvas_accessible_is_child_selected;
+	iface->remove_selection = panel_addto_canvas_accessible_remove_selection;
+	iface->select_all_selection = panel_addto_canvas_accessible_select_all_selection;
+}
+
+static AtkObject*
+panel_addto_canvas_accessible_ref_accessible_at_point (AtkComponent *component,
+						   gint          x,
+						   gint          y,
+						   AtkCoordType  coord_type)
+{
+	GSList                  *l, *m;
+	GtkWidget               *widget;
+	PanelAddtoCanvasPrivate *priv;
+	PanelAddtoCanvas        *canvas;
+	PanelAddtoCategory      *current_category;
+	EntryInfo               *entry;
+	gint x_pos, y_pos, x_w, y_w;
+
+	widget = GTK_ACCESSIBLE (component)->widget;
+
+	if (widget == NULL)
+		return NULL;
+
+	canvas = PANEL_ADDTO_CANVAS (widget);
+	priv   = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+
+	atk_component_get_extents (component, &x_pos, &y_pos, NULL, NULL, coord_type);
+	x_w = x - x_pos;
+	y_w = y - y_pos;
+
+	for (l = priv->info->categories; l; l = l->next) {
+		current_category = l->data;
+		for (m = current_category->entries; m; m = m->next) {
+			entry = (EntryInfo *) m->data; 
+			
+			if (x_w > entry->cover->x1 &&
+			    x_w < entry->cover->x2 &&
+			    y_w > entry->cover->y1 &&
+			    y_w < entry->cover->y2)
+				return panel_addto_canvas_accessible_ref_child (ATK_OBJECT (component), entry->index);
+		}
+	}
+
+	return NULL;
+}
+
+static void
+atk_component_interface_init (AtkComponentIface *iface)
+{
+	iface->ref_accessible_at_point = panel_addto_canvas_accessible_ref_accessible_at_point;
+}
+
+static GType
+panel_addto_canvas_accessible_get_type (void)
+{
+	static GType type = 0;
+	AtkObjectFactory *factory;
+	GType derived_type;
+	GTypeQuery query;
+	GType derived_atk_type;
+
+	if (type == 0) {
+		static GTypeInfo info = {
+			0, /* class size */
+			(GBaseInitFunc) NULL, /* base init */
+			(GBaseFinalizeFunc) NULL, /* base finalize */
+			(GClassInitFunc) panel_addto_canvas_accessible_class_init,
+			(GClassFinalizeFunc) NULL, /* class finalize */
+			NULL, /* class data */
+			0, /* instance size */
+			0, /* nb preallocs */
+			(GInstanceInitFunc) NULL, /* instance init */
+			NULL /* value table */
+		};
+
+		static const GInterfaceInfo  atk_component_info = {
+			(GInterfaceInitFunc) atk_component_interface_init,
+			(GInterfaceFinalizeFunc) NULL,
+			NULL
+		};
+
+		static const GInterfaceInfo atk_selection_info = {
+			(GInterfaceInitFunc) panel_addto_canvas_accessible_selection_interface_init,
+			(GInterfaceFinalizeFunc) NULL,
+			NULL
+		};
+
+		derived_type = g_type_parent (PANEL_ADDTO_TYPE_CANVAS);
+		factory = atk_registry_get_factory (atk_get_default_registry (),
+						    derived_type);
+
+		derived_atk_type = atk_object_factory_get_accessible_type (factory);
+		g_type_query (derived_atk_type, &query);
+
+		info.class_size = query.class_size;
+		info.instance_size = query.instance_size;
+
+		type = g_type_register_static (derived_atk_type,
+					       "PanelAddtoCanvasAccessible",
+					       &info, 0);
+
+		g_type_add_interface_static (type,
+					     ATK_TYPE_COMPONENT,
+					     &atk_component_info);
+		g_type_add_interface_static (type,
+					     ATK_TYPE_SELECTION,
+					     &atk_selection_info);
+	}
+
+	return type;
+}
+
+static AtkObject*
+panel_addto_canvas_accessible_new (GObject *object)
+{
+	AtkObject *accessible;
+
+	accessible = g_object_new (panel_addto_canvas_accessible_get_type (), NULL);
+	atk_object_initialize (accessible, object);
+
+	return accessible;
+}
+
+static AtkObject*
+panel_addto_canvas_accessible_factory_create_accessible (GObject *object)
+{
+	return panel_addto_canvas_accessible_new (object);
+}
+
+static void
+panel_addto_canvas_accessible_factory_class_init (AtkObjectFactoryClass *class)
+{
+	class->create_accessible   = panel_addto_canvas_accessible_factory_create_accessible;
+	class->get_accessible_type = panel_addto_canvas_accessible_get_type;
+}
+
+static GType
+panel_addto_canvas_accessible_factory_get_type (void)
+{
+	static GType type = 0;
+
+	if (type == 0) {
+		static const GTypeInfo info = {
+			sizeof (AtkObjectFactoryClass),
+			NULL,           /* base_init */
+			NULL,           /* base_finalize */
+			(GClassInitFunc) panel_addto_canvas_accessible_factory_class_init,
+			NULL,           /* class_finalize */
+			NULL,           /* class_data */
+			sizeof (AtkObjectFactory),
+			0,             /* n_preallocs */
+			NULL, NULL
+		};
+
+		type = g_type_register_static (ATK_TYPE_OBJECT_FACTORY,
+					       "PanelAddtoCanvasAccessibleFactory",
+					       &info, 0);
+	}
+
+	return type;
+}
+
+static AtkObject*
+panel_addto_canvas_get_accessible (GtkWidget *widget)
+{
+	static gboolean already_here = FALSE;
+
+	if (!already_here) {
+		AtkObjectFactory *factory;
+		AtkRegistry *registry;
+		GType derived_type;
+		GType derived_atk_type;
+
+		already_here = TRUE;
+
+		derived_type = g_type_parent (PANEL_ADDTO_TYPE_CANVAS);
+
+		registry = atk_get_default_registry ();
+		factory  = atk_registry_get_factory (registry, derived_type);
+
+		derived_atk_type = atk_object_factory_get_accessible_type (factory);
+
+		if (g_type_is_a (derived_atk_type, GTK_TYPE_ACCESSIBLE)) {
+			atk_registry_set_factory_type (registry,
+						       PANEL_ADDTO_TYPE_CANVAS,
+						       panel_addto_canvas_accessible_factory_get_type ());
+		}
+	}
+
+	return (* GTK_WIDGET_CLASS (panel_addto_canvas_parent_class)->get_accessible) (widget);
+}
diff -Nur gnome-panel-2.16.1/gnome-panel/panel-addto-canvas.h gnome-panel-2.16.1.new/gnome-panel/panel-addto-canvas.h
--- gnome-panel-2.16.1/gnome-panel/panel-addto-canvas.h	1970-01-01 01:00:00.000000000 +0100
+++ gnome-panel-2.16.1.new/gnome-panel/panel-addto-canvas.h	2006-10-03 01:10:39.000000000 +0200
@@ -0,0 +1,88 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+/* Copyright (C) 2005 Carlos Garnacho
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Authors: Jody Goldberg          <jody@gnome.org>
+ *          Carlos Garnacho Parro  <carlosg@gnome.org>
+ *          Manu Cornet            <manu@manucornet.net>
+ */
+
+#ifndef PANEL_ADDTO_CANVAS_H
+#define PANEL_ADDTO_CANVAS_H
+
+#include <libgnomecanvas/gnome-canvas.h>
+#include <gnome.h>
+#include "panel-addto.h"
+
+G_BEGIN_DECLS
+
+#define PANEL_ADDTO_TYPE_CANVAS         (panel_addto_canvas_get_type ())
+#define PANEL_ADDTO_CANVAS(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), PANEL_ADDTO_TYPE_CANVAS, PanelAddtoCanvas))
+#define PANEL_ADDTO_CANVAS_CLASS(c)     (G_TYPE_CHECK_CLASS_CAST    ((c), PANEL_ADDTO_TYPE_CANVAS, PanelAddtoCanvasClass))
+#define PANEL_ADDTO_IS_CANVAS(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), PANEL_ADDTO_TYPE_CANVAS))
+#define PANEL_ADDTO_IS_CANVAS_CLASS(c)  (G_TYPE_CHECK_CLASS_TYPE    ((c), PANEL_ADDTO_TYPE_CANVAS))
+#define PANEL_ADDTO_CANVAS_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS  ((o), PANEL_ADDTO_TYPE_CANVAS, PanelAddtoCanvasClass))
+
+typedef struct _PanelAddtoCanvas      PanelAddtoCanvas;
+typedef struct _PanelAddtoCanvasClass PanelAddtoCanvasClass;
+
+struct _PanelAddtoCanvas {
+	GnomeCanvas parent;
+};
+
+struct _PanelAddtoCanvasClass {
+	GnomeCanvasClass parent_class;
+
+	void (*changed) (PanelAddtoCanvas *canvas, gchar *str);
+};
+
+typedef struct _PanelAddtoCanvasPrivate PanelAddtoCanvasPrivate;
+
+struct _PanelAddtoCanvasPrivate {
+	GnomeCanvasItem *under_cover;
+	double height;
+	double width;
+
+	double min_height;
+	double max_width;
+	PanelAddtoInformation *info;
+	PanelAddtoEntry *selected;
+
+	gboolean rtl;
+	gint items_per_row;
+	gint selected_row;
+
+	gchar *search_text;
+
+	/* calculated sizes
+	   for the elements */
+	gdouble max_item_width;
+	gdouble max_item_height;
+	gdouble max_icon_height;
+
+	/* accessibility stuff */
+	GHashTable *accessible_children;
+};
+
+GType panel_addto_canvas_get_type (void);
+void activate_entry (PanelAddtoEntry *entry);
+void panel_addto_relayout_for_search (GtkWidget *search_entry, PanelAddtoDialog *dialog);
+void panel_addto_activate_from_searchbar (GtkWidget *search_entry, PanelAddtoDialog *dialog);
+GtkWidget* panel_addto_canvas_new (PanelAddtoInformation *info);
+
+G_END_DECLS
+
+#endif /* PANEL_ADDTO_CANVAS_H */
diff -Nur gnome-panel-2.16.1/gnome-panel/panel-addto-event-box.c gnome-panel-2.16.1.new/gnome-panel/panel-addto-event-box.c
--- gnome-panel-2.16.1/gnome-panel/panel-addto-event-box.c	1970-01-01 01:00:00.000000000 +0100
+++ gnome-panel-2.16.1.new/gnome-panel/panel-addto-event-box.c	2006-10-03 01:10:39.000000000 +0200
@@ -0,0 +1,99 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+/*
+ * Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002 Free Software Foundation
+ * All rights reserved.
+ *
+ * This file is part of the Gnome Library.
+ *
+ * The Gnome Library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Gnome Library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with the Gnome Library; see the file COPYING.LIB.  If not,
+ * write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+/*
+  @NOTATION@
+ */
+/* Event box item type for GnomeCanvas widget
+ *
+ * GnomeCanvas is basically a port of the Tk toolkit's most excellent canvas widget.  Tk is
+ * copyrighted by the Regents of the University of California, Sun Microsystems, and other parties.
+ *
+ *
+ * Author: Chris Lahey <clahey@ximian.com>
+ */
+
+#include <config.h>
+
+#include "panel-addto-event-box.h"
+
+#define noVERBOSE
+
+static GnomeCanvasItemClass *parent_class;
+
+static double
+panel_addto_event_box_point (GnomeCanvasItem *item, double x, double y, int cx, int cy,
+			     GnomeCanvasItem **actual_item)
+{
+	double x1, x2, y1, y2;
+	g_object_get (item,
+		      "x1", &x1,
+		      "x2", &x2,
+		      "y1", &y1,
+		      "y2", &y2,
+		      NULL);
+	if (x <= x2 && x >= x1 &&
+	    y <= y2 && y >= y1) {
+		*actual_item = item;
+		
+		return 0.0;
+	}
+	return 1e12;
+}
+
+static void
+panel_addto_event_box_class_init (PanelAddtoEventBoxClass *class)
+{
+	GnomeCanvasItemClass *item_class;
+
+	item_class = (GnomeCanvasItemClass *) class;
+
+	parent_class = g_type_class_peek_parent (class);
+
+	item_class->point = panel_addto_event_box_point;
+}
+
+GType
+panel_addto_event_box_get_type (void)
+{
+	static GType type;
+
+	if (!type) {
+		static const GTypeInfo object_info = {
+			sizeof (PanelAddtoEventBoxClass),
+			(GBaseInitFunc) NULL,
+			(GBaseFinalizeFunc) NULL,
+			(GClassInitFunc) panel_addto_event_box_class_init,
+			(GClassFinalizeFunc) NULL,
+			NULL,			/* class_data */
+			sizeof (PanelAddtoEventBox),
+			0,			/* n_preallocs */
+			(GInstanceInitFunc) NULL,
+			NULL			/* value_table */
+		};
+
+		type = g_type_register_static (GNOME_TYPE_CANVAS_RECT, "PanelAddtoEventBox",
+					       &object_info, 0);
+	}
+
+	return type;
+}
diff -Nur gnome-panel-2.16.1/gnome-panel/panel-addto-event-box.h gnome-panel-2.16.1.new/gnome-panel/panel-addto-event-box.h
--- gnome-panel-2.16.1/gnome-panel/panel-addto-event-box.h	1970-01-01 01:00:00.000000000 +0100
+++ gnome-panel-2.16.1.new/gnome-panel/panel-addto-event-box.h	2006-10-03 01:10:39.000000000 +0200
@@ -0,0 +1,75 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+/*
+ * Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002 Free Software Foundation
+ * All rights reserved.
+ *
+ * This file is part of the Gnome Library.
+ *
+ * The Gnome Library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Gnome Library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with the Gnome Library; see the file COPYING.LIB.  If not,
+ * write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+/*
+  @NOTATION@
+ */
+/* Event Box item type for GnomeCanvas widget
+ *
+ * GnomeCanvas is basically a port of the Tk toolkit's most excellent canvas widget.  Tk is
+ * copyrighted by the Regents of the University of California, Sun Microsystems, and other parties.
+ *
+ *
+ * Author: Chris Lahey <clahey@ximian.com>
+ */
+
+#ifndef PANEL_ADDTO_EVENT_BOX_H
+#define PANEL_ADDTO_EVENT_BOX_H
+
+
+#include <libgnomecanvas/gnome-canvas.h>
+
+#include <libgnomecanvas/gnome-canvas-rect-ellipse.h>
+
+G_BEGIN_DECLS
+
+/* Event Box item.  No configurable or queryable arguments are available (use those in
+ * GnomeCanvasRE).
+ */
+
+
+#define PANEL_ADDTO_TYPE_EVENT_BOX            (panel_addto_event_box_get_type ())
+#define PANEL_ADDTO_EVENT_BOX(obj)            (GTK_CHECK_CAST ((obj), PANEL_ADDTO_TYPE_EVENT_BOX, PanelAddtoEventBox))
+#define PANEL_ADDTO_EVENT_BOX_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), PANEL_ADDTO_TYPE_EVENT_BOX, PanelAddtoEventBoxClass))
+#define PANEL_ADDTO_IS_EVENT_BOX(obj)         (GTK_CHECK_TYPE ((obj), PANEL_ADDTO_TYPE_EVENT_BOX))
+#define PANEL_ADDTO_IS_EVENT_BOX_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), PANEL_ADDTO_TYPE_EVENT_BOX))
+#define PANEL_ADDTO_EVENT_BOX_GET_CLASS(obj)  (GTK_CHECK_GET_CLASS ((obj), PANEL_ADDTO_TYPE_EVENT_BOX, PanelAddtoEventBoxClass))
+
+
+typedef struct _PanelAddtoEventBox      PanelAddtoEventBox;
+typedef struct _PanelAddtoEventBoxClass PanelAddtoEventBoxClass;
+
+struct _PanelAddtoEventBox {
+	GnomeCanvasRect item;
+};
+
+struct _PanelAddtoEventBoxClass {
+	GnomeCanvasRectClass parent_class;
+};
+
+
+/* Standard Gtk function */
+GType panel_addto_event_box_get_type (void) G_GNUC_CONST;
+
+G_END_DECLS
+
+#endif
diff -Nur gnome-panel-2.16.1/gnome-panel/panel-addto.h gnome-panel-2.16.1.new/gnome-panel/panel-addto.h
--- gnome-panel-2.16.1/gnome-panel/panel-addto.h	2004-06-23 00:21:51.000000000 +0200
+++ gnome-panel-2.16.1.new/gnome-panel/panel-addto.h	2006-10-03 01:10:39.000000000 +0200
@@ -20,6 +20,7 @@
  *
  * Authors:
  *	Vincent Untz <vincent@vuntz.net>
+ *	Manu Cornet <manu@manucornet.net>
  */
 
 #ifndef __PANEL_ADDTO_H__
@@ -27,8 +28,144 @@
 
 G_BEGIN_DECLS
 
-void panel_addto_present                    (GtkMenuItem *item,
-					     PanelWidget *panel_widget);
+#include <libgnomecanvas/libgnomecanvas.h>
+#include <libgnome/gnome-desktop-item.h>
+#include <gconf/gconf-client.h>
+#include <gdk/gdkkeysyms.h>
+#include <gtk/gtk.h>
+#include <atk/atk.h>
+
+#include "menu.h"
+
+#include "launcher.h"
+#include "panel.h"
+#include "drawer.h"
+#include "panel-applet-frame.h"
+#include "panel-action-button.h"
+#include "panel-menu-bar.h"
+#include "panel-separator.h"
+#include "panel-toplevel.h"
+#include "panel-menu-button.h"
+#include "panel-globals.h"
+#include "panel-lockdown.h"
+#include "panel-util.h"
+#include "panel-profile.h"
+
+typedef struct PanelAddtoEntry PanelAddtoEntry;
+
+typedef struct PanelAddtoInformation {
+	GSList *categories;
+	int n_categories;
+} PanelAddtoInformation;
+
+typedef struct {
+	PanelWidget           *panel_widget;
+	PanelAddtoInformation *info;
+
+	GtkWidget          *addto_dialog;
+	GtkWidget          *label;
+	GtkWidget          *back_button;
+	GtkWidget          *add_button;
+	GtkWidget          *tree_view;
+	GtkWidget          *canvas;
+	GtkWidget          *applets_sw;
+        GtkWidget          *applications_sw;
+        GtkWidget          *inner_vbox;
+        GtkWidget          *statuslabel;
+        GtkWidget          *search_entry;
+        GtkWidget          *search_label;
+        GtkWidget          *launcher_button;
+        GtkWidget          *custom_launcher_button;
+        GtkCellRenderer    *renderer;
+	GtkTreeModel       *applet_model;
+	GtkTreeModel       *application_model;
+
+	GMenuTree    *menu_tree;
+
+	GSList       *applet_list;
+	GSList       *application_list;
+	GSList       *settings_list;
+	guint         name_notify;
+	int           insertion_position;
+
+        gint status;
+} PanelAddtoDialog;
+
+enum {
+        APPLETS,
+        APPLICATIONS
+};
+
+typedef enum {
+	PANEL_ADDTO_APPLET,
+	PANEL_ADDTO_ACTION,
+	PANEL_ADDTO_LAUNCHER_MENU,
+	PANEL_ADDTO_LAUNCHER,
+	PANEL_ADDTO_LAUNCHER_NEW,
+	PANEL_ADDTO_MENU,
+	PANEL_ADDTO_MENUBAR,
+	PANEL_ADDTO_SEPARATOR,
+	PANEL_ADDTO_DRAWER
+} PanelAddtoItemType;
+
+
+typedef struct PanelAddtoCategory {
+	GSList *entries;
+	int n_entries;
+
+	char *title;
+	char *english_title;
+
+        gboolean translated;
+
+	gpointer user_data;
+
+	guint real_category : 1;
+} PanelAddtoCategory;
+
+typedef struct PanelAddtoItemInfo {
+	PanelAddtoItemType       type;
+	PanelActionButtonType    action_type;
+	char                    *category;
+	char                    *english_category;
+	char                    *name;
+	char                    *description;
+	char                    *icon;
+	char                    *launcher_path;
+	char                    *menu_filename;
+	char                    *menu_path;
+	char                    *iid;
+	gboolean                 static_data;
+} PanelAddtoItemInfo;
+
+struct PanelAddtoEntry {
+	PanelAddtoCategory *category;
+        PanelAddtoItemInfo *item_info;
+	PanelAddtoDialog *dialog;
+
+	char *title;
+	char *comment;
+
+	GdkPixbuf *icon_pixbuf;
+
+	gpointer user_data;
+};
+
+
+typedef struct {
+	GSList             *children;
+	PanelAddtoItemInfo  item_info;
+} PanelAddtoAppList;
+
+void
+panel_addto_dialog_response (GtkWidget *widget_dialog,
+			     guint response_id,
+			     PanelAddtoDialog *dialog);
+gboolean panel_addto_add_item (PanelAddtoDialog   *dialog,
+			       PanelAddtoItemInfo *item_info);
+void panel_addto_debug_print  (PanelAddtoInformation *info);
+void panel_addto_present      (GtkMenuItem *item,
+                               PanelWidget *panel_widget);
 
 G_END_DECLS
 
diff -Nur gnome-panel-2.16.1/gnome-panel/panel-addto-rounded-rect.c gnome-panel-2.16.1.new/gnome-panel/panel-addto-rounded-rect.c
--- gnome-panel-2.16.1/gnome-panel/panel-addto-rounded-rect.c	1970-01-01 01:00:00.000000000 +0100
+++ gnome-panel-2.16.1.new/gnome-panel/panel-addto-rounded-rect.c	2006-10-03 01:10:39.000000000 +0200
@@ -0,0 +1,103 @@
+/* vim: set sw=8: -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+/*
+ * panel-addto-rounded-rect.c: A rectangle with rounded corners
+ *
+ * Copyright (C) 2004 Novell Inc
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of version 2 of the GNU General Public
+ * License as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+ * USA
+ */
+
+#include <config.h>
+#include "panel-addto-rounded-rect.h"
+#include "panel-addto-rounded-rect-pixbuf.h"
+#include <glib-object.h>
+#include <math.h>
+
+struct _PanelAddtoRoundedRect {
+	GnomeCanvasRect base;
+};
+typedef GnomeCanvasRectClass PanelAddtoRoundedRectClass;
+
+#define GNOMECC_ROUNDED_RECT_CLASS(k)	 (G_TYPE_CHECK_CLASS_CAST ((k), GNOMECC_TYPE_ROUNDED_RECT, PanelAddtoRoundedRectClass))
+#define GNOMECC_IS_ROUNDED_RECT_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), GNOMECC_TYPE_ROUNDED_RECT))
+
+G_DEFINE_TYPE (PanelAddtoRoundedRect, panel_addto_rounded_rect, GNOME_TYPE_CANVAS_RECT);
+
+/*************************************************************************
+ * Adapted from nautilus/libnautilus-private/nautilus-icon-canvas-item.c
+ */
+/* clear the corners of the selection pixbuf by copying the corners of the passed-in pixbuf */
+static void
+panel_addto_rounded_rect_draw (GnomeCanvasItem *item, GdkDrawable *drawable,
+			   int x, int y, int width, int height)
+{
+	static GdkPixbuf *corner_pixbuf = NULL;
+	GnomeCanvasRE const *re = GNOME_CANVAS_RE (item);
+	int dest_width, dest_height, src_width, src_height;
+	int dx, dy;
+	int corner_size = 5;
+	double affine[6];
+
+	GNOME_CANVAS_ITEM_CLASS (panel_addto_rounded_rect_parent_class)->draw (item, drawable, x, y, width, height);
+
+	if (corner_pixbuf == NULL)
+		corner_pixbuf = gdk_pixbuf_new_from_inline (-1,
+			panel_addto_rounded_rect_frame, FALSE, NULL);
+	src_width = gdk_pixbuf_get_width (corner_pixbuf);
+	src_height = gdk_pixbuf_get_height (corner_pixbuf);
+
+	gnome_canvas_item_i2c_affine (item, affine);
+
+	dest_width = fabs (re->x2 - re->x1);
+	dest_height = fabs (re->y2 - re->y1);
+	dx = affine[4] - x;
+	dy = affine[5] - y;
+	
+	/* draw top left corner */
+	gdk_draw_pixbuf (drawable, NULL, corner_pixbuf,
+			 0, 0,
+			 dx, dy,
+			 corner_size, corner_size,
+			 GDK_RGB_DITHER_NORMAL, 0, 0);
+	/* draw top right corner */
+	gdk_draw_pixbuf (drawable, NULL, corner_pixbuf,
+			 src_width - corner_size, 0,
+			 dx + dest_width - corner_size, dy,
+			 corner_size, corner_size,
+			 GDK_RGB_DITHER_NORMAL, 0, 0);
+	/* draw bottom left corner */
+	gdk_draw_pixbuf (drawable, NULL, corner_pixbuf,
+			 0, src_height - corner_size,
+			 dx, dy + dest_height - corner_size,
+			 corner_size, corner_size,
+			 GDK_RGB_DITHER_NORMAL, 0, 0);
+	/* draw bottom right corner */
+	gdk_draw_pixbuf (drawable, NULL, corner_pixbuf,
+			 src_width - corner_size, src_height - corner_size,
+			 dx + dest_width - corner_size, dy + dest_height - corner_size,
+			 corner_size, corner_size,
+			 GDK_RGB_DITHER_NORMAL, 0, 0);
+}
+
+static void
+panel_addto_rounded_rect_class_init (PanelAddtoRoundedRectClass *klass)
+{
+	GnomeCanvasItemClass	*item_klass = (GnomeCanvasItemClass *) klass;
+	item_klass->draw	= panel_addto_rounded_rect_draw;
+}
+static void
+panel_addto_rounded_rect_init (PanelAddtoRoundedRect *rr)
+{
+}
diff -Nur gnome-panel-2.16.1/gnome-panel/panel-addto-rounded-rect.h gnome-panel-2.16.1.new/gnome-panel/panel-addto-rounded-rect.h
--- gnome-panel-2.16.1/gnome-panel/panel-addto-rounded-rect.h	1970-01-01 01:00:00.000000000 +0100
+++ gnome-panel-2.16.1.new/gnome-panel/panel-addto-rounded-rect.h	2006-10-03 01:10:39.000000000 +0200
@@ -0,0 +1,39 @@
+/* vim: set sw=8: -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+/*
+ * gnomecc-rounded-rect.c: A rectangle with rounded corners
+ *
+ * Copyright (C) 2004 Novell Inc
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of version 2 of the GNU General Public
+ * License as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+ * USA
+ */
+#ifndef PANEL_ADDTO_ROUNDED_RECT_H
+#define PANEL_ADDTO_ROUNDED_RECT_H
+
+#include <libgnomecanvas/gnome-canvas.h>
+#include <libgnomecanvas/gnome-canvas-rect-ellipse.h>
+#include <glib-object.h>
+
+G_BEGIN_DECLS
+
+#define PANEL_ADDTO_TYPE_ROUNDED_RECT	(panel_addto_rounded_rect_get_type ())
+#define PANEL_ADDTO_ROUNDED_RECT(o)		(G_TYPE_CHECK_INSTANCE_CAST ((o), PANEL_ADDTO_TYPE_ROUNDED_RECT, PanelAddtoRoundedRect))
+#define PANEL_ADDTO_IS_ROUNDED_RECT(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), PANEL_ADDTO_TYPE_ROUNDED_RECT))
+
+typedef struct _PanelAddtoRoundedRect PanelAddtoRoundedRect;
+GType panel_addto_rounded_rect_get_type (void);
+
+G_END_DECLS
+
+#endif /* PANEL_ADDTO_ROUNDED_RECT_H */
diff -Nur gnome-panel-2.16.1/gnome-panel/panel-addto-rounded-rect-pixbuf.h gnome-panel-2.16.1.new/gnome-panel/panel-addto-rounded-rect-pixbuf.h
--- gnome-panel-2.16.1/gnome-panel/panel-addto-rounded-rect-pixbuf.h	1970-01-01 01:00:00.000000000 +0100
+++ gnome-panel-2.16.1.new/gnome-panel/panel-addto-rounded-rect-pixbuf.h	2006-10-03 01:10:39.000000000 +0200
@@ -0,0 +1,319 @@
+/* GdkPixbuf RGBA C-Source image dump */
+
+#ifdef __SUNPRO_C
+#pragma align 4 (panel_addto_rounded_rect_frame)
+#endif
+#ifdef __GNUC__
+static const guint8 panel_addto_rounded_rect_frame[] __attribute__ ((__aligned__ (4))) = 
+#else
+static const guint8 panel_addto_rounded_rect_frame[] = 
+#endif
+{ ""
+  /* Pixbuf magic (0x47646b50) */
+  "GdkP"
+  /* length: header (24) + pixel_data (5848) */
+  "\0\0\26\360"
+  /* pixdata_type (0x1010002) */
+  "\1\1\0\2"
+  /* rowstride (344) */
+  "\0\0\1X"
+  /* width (86) */
+  "\0\0\0V"
+  /* height (17) */
+  "\0\0\0\21"
+  /* pixel_data: */
+  "\377\377\377\377\377\377\377\377\377\377\377\303\377\377\377q\377\377"
+  "\377/\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377/\377\377\377q\377\377\377\303\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377\242\377\377\377"
+  "(\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377(\377\377\377\242\377\377\377\377\377\377\377\303\377\377"
+  "\377(\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377(\377\377\377\303\377\377"
+  "\377q\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377q\377\377\377/\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377/\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377/\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377/\377\377"
+  "\377q\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377q\377\377\377\303\377\377\377(\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377(\377\377\377\303\377\377\377\377\377\377\377\242\377\377\377(\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377(\377\377\377\242\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\303\377\377\377q\377\377\377/\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377/\377\377\377q\377\377\377\303\377\377\377\377\377\377\377\377"};
+
+
diff -Nur gnome-panel-2.16.1/panel-addto-canvas.c gnome-panel-2.16.1.new/panel-addto-canvas.c
--- gnome-panel-2.16.1/panel-addto-canvas.c	1970-01-01 01:00:00.000000000 +0100
+++ gnome-panel-2.16.1.new/panel-addto-canvas.c	2006-10-03 01:10:39.000000000 +0200
@@ -0,0 +1,2309 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+/* Copyright (C) 2005 Carlos Garnacho
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Authors: Jody Goldberg          <jody@gnome.org>
+ *          Carlos Garnacho Parro  <carlosg@gnome.org>
+ *          Manu Cornet            <manu@manucornet.net>
+ */
+
+
+#include "panel-addto-canvas.h"
+#include "panel-addto.h"
+#include "panel-profile.h"
+
+#define PAD 5 /*when scrolling keep a few pixels above or below if possible */
+#define ABOVE_LINE_SPACING 0
+#define UNDER_LINE_SPACING 0
+#define UNDER_TITLE_SPACING 0 /* manually insert 1 blank line of text */
+#define LINE_HEIGHT 1
+#define BORDERS 7
+#define MAX_ITEM_WIDTH	125
+#define ITEMS_SEPARATION 7
+
+#include "panel-addto-canvas.h"
+#include "panel-addto-event-box.h"
+#include "panel-addto-rounded-rect.h"
+
+#include <libgnomecanvas/libgnomecanvas.h>
+#include <libgnome/gnome-desktop-item.h>
+#include <gconf/gconf-client.h>
+#include <gdk/gdkkeysyms.h>
+#include <atk/atk.h>
+
+#define PANEL_ADDTO_CANVAS_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), PANEL_ADDTO_TYPE_CANVAS, PanelAddtoCanvasPrivate))
+
+typedef struct EntryInfo {
+	PanelAddtoCanvas *canvas;
+
+	GnomeCanvasGroup     *group;
+	GnomeCanvasItem      *text;
+	GnomeCanvasItem      *pixbuf;
+	GnomeCanvasItem      *highlight_pixbuf;
+	GnomeCanvasItem      *cover;
+	GnomeCanvasItem      *selection;
+
+	double    icon_height;
+	double    icon_width;
+	double    text_height;
+	guint     launching : 1;
+	guint     selected : 1;
+	guint     highlighted : 1;
+	gboolean  visible;
+
+	gint n_category;
+	gint n_entry;
+	gint index;
+} EntryInfo;
+
+typedef struct {
+	GnomeCanvasGroup *group;
+	GnomeCanvasItem  *title;
+	GnomeCanvasItem  *line;
+	gboolean          visible;
+} CategoryInfo;
+
+enum {
+	SELECTION_CHANGED,
+	LAST_SIGNAL
+};
+
+enum {
+	PROP_0,
+	PROP_INFO
+};
+
+
+static guint panel_addto_canvas_signals [LAST_SIGNAL] = { 0 };
+
+
+static void panel_addto_canvas_class_init (PanelAddtoCanvasClass *class);
+static void panel_addto_canvas_init       (PanelAddtoCanvas      *canvas);
+static void panel_addto_canvas_finalize   (GObject            *object);
+static void panel_addto_canvas_set_property (GObject      *object,
+					     guint         prop_id,
+					     const GValue *value,
+					     GParamSpec   *pspec);
+static void panel_addto_canvas_get_property (GObject      *object,
+					     guint         prop_id,
+					     GValue       *value,
+					     GParamSpec   *pspec);
+static void panel_addto_canvas_draw_background (GnomeCanvas *canvas, GdkDrawable *drawable,
+					    int x, int y, int width, int height);
+static void panel_addto_canvas_size_allocate   (GtkWidget     *canvas,
+						GtkAllocation *allocation);
+static void panel_addto_canvas_style_set       (GtkWidget     *canvas,
+						GtkStyle      *previous_style);
+static void panel_addto_canvas_realize         (GtkWidget     *canvas);
+
+static void panel_addto_select_east_entry (EntryInfo *ei, PanelAddtoCanvas *canvas);
+static void build_canvas (PanelAddtoCanvas *canvas);
+static void relayout_canvas (PanelAddtoCanvas *canvas);
+static void set_style (PanelAddtoCanvas *canvas, gboolean font_changed);
+
+G_DEFINE_TYPE (PanelAddtoCanvas, panel_addto_canvas, GNOME_TYPE_CANVAS);
+
+
+static AtkObject* panel_addto_canvas_get_accessible (GtkWidget *widget);
+
+#include "panel-addto-event-box.h"
+#include "panel-addto-rounded-rect.h"
+#include "panel-profile.h"
+
+static void
+panel_addto_canvas_class_init (PanelAddtoCanvasClass *class)
+{
+	GObjectClass     *object_class = G_OBJECT_CLASS (class);
+	GnomeCanvasClass *canvas_class = GNOME_CANVAS_CLASS (class);
+	GtkWidgetClass   *widget_class = GTK_WIDGET_CLASS (class);
+
+	object_class->set_property = panel_addto_canvas_set_property;
+	object_class->get_property = panel_addto_canvas_get_property;
+	object_class->finalize = panel_addto_canvas_finalize;
+	canvas_class->draw_background = panel_addto_canvas_draw_background;
+
+	widget_class->style_set = panel_addto_canvas_style_set;
+	widget_class->size_allocate = panel_addto_canvas_size_allocate;
+	widget_class->realize = panel_addto_canvas_realize;
+	widget_class->get_accessible = panel_addto_canvas_get_accessible;
+
+	class->changed = NULL;
+
+	g_object_class_install_property (object_class,
+					 PROP_INFO,
+					 g_param_spec_pointer ("info",
+							       "information for the canvas",
+							       "information for the canvas",
+							       G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
+	panel_addto_canvas_signals [SELECTION_CHANGED] =
+		g_signal_new ("selection-changed",
+			      G_OBJECT_CLASS_TYPE (object_class),
+			      G_SIGNAL_RUN_LAST,
+			      G_STRUCT_OFFSET (PanelAddtoCanvasClass, changed),
+			      NULL, NULL,
+			      g_cclosure_marshal_VOID__STRING,
+			      G_TYPE_NONE, 1,
+			      G_TYPE_STRING);
+
+	g_type_class_add_private (object_class,
+				  sizeof (PanelAddtoCanvasPrivate));
+}
+
+
+static void
+panel_addto_canvas_init (PanelAddtoCanvas *canvas)
+{
+	PanelAddtoCanvasPrivate *priv;
+	
+	g_return_if_fail (PANEL_ADDTO_IS_CANVAS (canvas));
+
+	priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+
+	priv->max_width = 300;
+	priv->min_height = 0;
+	priv->info = NULL;
+	priv->selected = NULL;
+
+	priv->max_item_width = 0;
+	priv->max_item_height = 0;
+	priv->items_per_row = 0;
+	priv->rtl = (gtk_widget_get_direction (GTK_WIDGET (canvas)) == GTK_TEXT_DIR_RTL);
+	priv->accessible_children = g_hash_table_new (g_int_hash, g_int_equal);
+
+	gtk_widget_show_all (GTK_WIDGET (canvas));
+}
+
+static void
+panel_addto_canvas_set_property (GObject      *object,
+			     guint         prop_id,
+			     const GValue *value,
+			     GParamSpec   *pspec)
+{
+	PanelAddtoCanvasPrivate *priv;
+
+	priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (object);
+
+	switch (prop_id) {
+	case PROP_INFO:
+		priv->info = g_value_get_pointer (value);
+		build_canvas (PANEL_ADDTO_CANVAS (object));
+		break;
+	}
+}
+
+static void
+panel_addto_canvas_get_property (GObject      *object,
+			     guint         prop_id,
+			     GValue       *value,
+			     GParamSpec   *pspec)
+{
+	PanelAddtoCanvasPrivate *priv;
+
+	priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (object);
+
+	switch (prop_id) {
+	case PROP_INFO:
+		g_value_set_pointer (value, priv->info);
+		break;
+	}
+}
+
+static void
+panel_addto_canvas_finalize (GObject *object)
+{
+	if (G_OBJECT_CLASS (panel_addto_canvas_parent_class)->finalize)
+		(* G_OBJECT_CLASS (panel_addto_canvas_parent_class)->finalize) (object);
+}
+
+
+static void
+panel_addto_canvas_draw_background (GnomeCanvas *canvas, GdkDrawable *drawable,
+				int x, int y, int width, int height)
+{
+	/* By default, we use the style base color. */
+	gdk_gc_set_foreground (canvas->pixmap_gc,
+			       &GTK_WIDGET (canvas)->style->base[GTK_STATE_NORMAL]);
+	gdk_draw_rectangle (drawable,
+			    canvas->pixmap_gc,
+			    TRUE,
+			    0, 0,
+			    width, height);
+}
+
+static void
+panel_addto_canvas_size_allocate(GtkWidget *canvas, GtkAllocation *allocation)
+{
+	PanelAddtoCanvasPrivate *priv;
+
+	if (GTK_WIDGET_CLASS (panel_addto_canvas_parent_class)->size_allocate)
+		(* GTK_WIDGET_CLASS (panel_addto_canvas_parent_class)->size_allocate) (canvas, allocation);
+
+	if (allocation->height == 1 || allocation->width == 1)
+		return;
+
+	priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+	priv->max_width = allocation->width;
+	priv->min_height = allocation->height;
+
+	relayout_canvas (PANEL_ADDTO_CANVAS (canvas));
+
+	gnome_canvas_set_scroll_region (GNOME_CANVAS (canvas), 0, 0, priv->width - 1, priv->height - 1);
+	g_object_set (priv->under_cover,
+		      "x2", priv->width,
+		      "y2", priv->height,
+		      NULL);
+}
+
+static void
+panel_addto_canvas_realize (GtkWidget *canvas)
+{
+	if (GTK_WIDGET_CLASS (panel_addto_canvas_parent_class)->realize)
+		(* GTK_WIDGET_CLASS (panel_addto_canvas_parent_class)->realize) (canvas);
+
+	set_style (PANEL_ADDTO_CANVAS (canvas), FALSE);
+}
+
+static void
+panel_addto_canvas_style_set (GtkWidget *canvas, GtkStyle *previous_style)
+{
+	if (!GTK_WIDGET_REALIZED (canvas))
+		return;
+
+	set_style (PANEL_ADDTO_CANVAS (canvas), (previous_style &&
+					     canvas->style &&
+					     !pango_font_description_equal (canvas->style->font_desc,
+									    previous_style->font_desc)));
+}
+
+static void
+gnome_canvas_item_show_hide (GnomeCanvasItem *item, gboolean show)
+{
+	if (show)
+		gnome_canvas_item_show (item);
+	else
+		gnome_canvas_item_hide (item);
+}
+
+static void
+setup_entry (PanelAddtoCanvas *canvas, PanelAddtoEntry *entry)
+{
+	PanelAddtoCanvasPrivate *priv;
+	EntryInfo *ei;
+	GtkWidget *widget;
+	GtkStateType state;
+
+	if (!entry)
+		return;
+
+	priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+	widget = GTK_WIDGET (canvas);
+	ei = entry->user_data;
+
+	if (ei->pixbuf) {
+		gnome_canvas_item_show_hide (ei->highlight_pixbuf, ei->highlighted);
+		gnome_canvas_item_show_hide (ei->pixbuf, !ei->highlighted);
+	}
+	if (!ei->selected)
+		state = GTK_STATE_NORMAL;
+	else if (gtk_window_has_toplevel_focus (GTK_WINDOW (gtk_widget_get_toplevel (widget))))
+		state = GTK_STATE_SELECTED;
+	else
+		state = GTK_STATE_ACTIVE;
+	gnome_canvas_item_show_hide (ei->selection, ei->selected);
+	g_object_set (ei->selection,
+		      "fill_color_gdk", &widget->style->base [state],
+		      NULL);
+	g_object_set (ei->text,
+		      "fill_color_gdk", &widget->style->text [state],
+		      NULL);
+}
+
+static gboolean
+cb_entry_info_reset (gpointer data)
+{
+	EntryInfo *ei = data;
+	ei->launching = FALSE;
+	return FALSE;
+}
+
+
+void
+activate_entry (PanelAddtoEntry *entry)
+{
+	EntryInfo *ei = entry->user_data;
+
+	if (!ei->launching) {
+		ei->launching = TRUE;
+		gtk_timeout_add (1000, cb_entry_info_reset, ei);
+
+		if (panel_addto_add_item (entry->dialog, entry->item_info))
+			gtk_widget_destroy (entry->dialog->addto_dialog);
+		}
+}
+
+static void  
+panel_addto_drag_data_get_cb (GtkWidget        *widget,
+			      GdkDragContext   *context,
+			      GtkSelectionData *selection_data,
+			      guint             info,
+			      guint             time,
+			      const char       *string)
+{
+	gtk_selection_data_set (selection_data,
+				selection_data->target, 8, (guchar *) string,
+				strlen (string));
+}
+
+static void
+panel_addto_drag_begin_cb (GtkWidget      *canvas,
+			   GdkDragContext *context,
+			   gpointer        data)
+{
+	PanelAddtoEntry         *entry;
+	PanelAddtoCanvasPrivate *priv;
+
+	priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+	entry = priv->selected;
+	gtk_drag_set_icon_pixbuf (context, entry->icon_pixbuf, 0, 0);
+}
+
+static void
+panel_addto_setup_drag (PanelAddtoCanvas     *canvas,
+				     const GtkTargetEntry *target,
+				     const char           *text)
+{
+	if (!text || panel_lockdown_get_locked_down ())
+		return;
+
+	
+	gtk_drag_source_set (GTK_WIDGET (canvas),
+			     GDK_BUTTON1_MASK|GDK_BUTTON2_MASK,
+			     target, 1, GDK_ACTION_COPY);
+		
+	g_signal_connect_data (G_OBJECT (canvas), "drag_data_get",
+			       G_CALLBACK (panel_addto_drag_data_get_cb),
+			       g_strdup (text),
+			       (GClosureNotify) g_free,
+			       0 /* connect_flags */);
+	g_signal_connect_after (G_OBJECT (canvas), "drag-begin",
+	                        G_CALLBACK (panel_addto_drag_begin_cb),
+	                        NULL);
+}
+
+static void
+panel_addto_setup_launcher_drag (PanelAddtoCanvas *canvas,
+				 const char  *uri)
+{
+        static GtkTargetEntry target[] = {
+		{ "text/uri-list", 0, 0 }
+	};
+	char *uri_list;
+
+	uri_list = g_strconcat (uri, "\r\n", NULL);
+	panel_addto_setup_drag (canvas, target, uri_list);
+	g_free (uri_list);
+}
+
+static void
+panel_addto_setup_applet_drag (PanelAddtoCanvas *canvas,
+			       const char  *iid)
+{
+	static GtkTargetEntry target[] = {
+		{ "application/x-panel-applet-iid", 0, 0 }
+	};
+
+	panel_addto_setup_drag (canvas, target, iid);
+}
+
+
+
+static void
+panel_addto_setup_internal_applet_drag (PanelAddtoCanvas *canvas,
+					const char  *applet_type)
+{
+	static GtkTargetEntry target[] = {
+		{ "application/x-panel-applet-internal", 0, 0 }
+	};
+
+	panel_addto_setup_drag (canvas, target, applet_type);
+}
+
+static void
+panel_addto_selection_changed (PanelAddtoCanvas *canvas,
+			       const gchar *status_display,
+			       PanelAddtoDialog *dialog)
+{
+	PanelAddtoItemInfo      *data;
+	PanelAddtoCanvasPrivate *priv;
+
+	priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+	data = priv->selected ? priv->selected->item_info : NULL;
+
+
+	if ((!priv->selected) || (!data)) {
+		gtk_widget_set_sensitive (GTK_WIDGET (dialog->add_button), FALSE);
+		return;
+	}
+
+	gtk_widget_set_sensitive (GTK_WIDGET (dialog->add_button), TRUE);
+
+	if (dialog->statuslabel)
+		gtk_label_set_text (GTK_LABEL (dialog->statuslabel), priv->selected->comment);
+
+	if (data->type == PANEL_ADDTO_LAUNCHER_MENU) {
+		gtk_button_set_label (GTK_BUTTON (dialog->add_button),
+				      GTK_STOCK_GO_FORWARD);
+	} else {
+		gtk_button_set_label (GTK_BUTTON (dialog->add_button),
+				      GTK_STOCK_ADD);
+	}
+	gtk_button_set_use_stock (GTK_BUTTON (dialog->add_button),
+				  TRUE);
+
+}
+
+static void
+select_entry (PanelAddtoCanvas *canvas, PanelAddtoEntry *entry)
+{
+	PanelAddtoDialog        *dialog;
+	PanelAddtoCanvasPrivate *priv;
+	EntryInfo *ei = NULL;
+	GtkAdjustment *pos;
+	double affine[6];
+	PanelAddtoEntry *selected;
+
+	dialog = entry->dialog;
+	priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+	selected = priv->selected;
+
+	if (selected == entry)
+		return;
+
+	if (selected && selected->user_data)
+		((EntryInfo *) selected->user_data)->selected = FALSE;
+	setup_entry (canvas, selected);
+
+	priv->selected = selected = entry;
+
+	if (selected && selected->user_data)
+		((EntryInfo *) selected->user_data)->selected = TRUE;
+	setup_entry (canvas, selected);
+
+	g_signal_emit (canvas, panel_addto_canvas_signals [SELECTION_CHANGED], 0,
+		       (entry) ? entry->comment : NULL);
+
+	if (!entry)
+		return;
+
+	ei = entry->user_data;
+	gnome_canvas_item_i2c_affine (GNOME_CANVAS_ITEM (ei->group), affine);
+	pos = gtk_layout_get_vadjustment (GTK_LAYOUT (ei->cover->canvas));
+
+	if (affine[5] < pos->value)
+		gtk_adjustment_set_value (pos, MAX (affine[5] - PAD, 0));
+	else if ((affine[5] + priv->max_item_height) > (pos->value+pos->page_size))
+		gtk_adjustment_set_value (pos, MAX (MIN (affine[5] + priv->max_item_height + PAD, pos->upper) - pos->page_size, 0));
+}
+
+static gboolean
+cover_event (GnomeCanvasItem *item, GdkEvent *event, PanelAddtoEntry *entry)
+{
+	EntryInfo               *ei = entry->user_data;
+	PanelAddtoCanvas        *canvas = ei->canvas;
+	PanelAddtoItemInfo      *data;
+	PanelAddtoDialog        *dialog = entry->dialog;
+	char                    *iid;
+
+	data = entry->item_info;
+
+	switch (event->type) {
+	case GDK_ENTER_NOTIFY:
+		ei->highlighted = TRUE;
+		setup_entry (canvas, entry); /* highlight even if it is already selected */
+
+		/* only allow dragging applets if we can add applets */
+		if (panel_profile_id_lists_are_writable ()) {
+			switch (data->type) {
+			case PANEL_ADDTO_LAUNCHER:
+				panel_addto_setup_launcher_drag (PANEL_ADDTO_CANVAS (dialog->canvas),
+								 data->launcher_path);
+				break;
+			case PANEL_ADDTO_APPLET:
+				panel_addto_setup_applet_drag (PANEL_ADDTO_CANVAS (dialog->canvas),
+							       data->iid);
+				break;
+			case PANEL_ADDTO_LAUNCHER_MENU:
+				break;
+			case PANEL_ADDTO_MENU:
+				/* build the iid for menus other than the main menu */
+				if (data->iid == NULL) {
+					iid = g_strdup_printf ("MENU:%s/%s",
+							       data->menu_filename,
+							       data->menu_path);
+				} else {
+					iid = g_strdup (data->iid);
+				}
+				panel_addto_setup_internal_applet_drag (PANEL_ADDTO_CANVAS (dialog->canvas),
+									iid);
+				g_free (iid);
+				break;
+			default:
+				panel_addto_setup_internal_applet_drag (PANEL_ADDTO_CANVAS (dialog->canvas),
+									data->iid);
+				break;
+			}
+		}
+		
+		return TRUE;
+	case GDK_LEAVE_NOTIFY:
+		ei->highlighted = FALSE;
+		setup_entry (canvas, entry);
+		return TRUE;
+	case GDK_BUTTON_PRESS:
+		select_entry (canvas, entry);
+		gtk_widget_grab_focus (GTK_WIDGET (canvas));
+		return TRUE;
+	case GDK_2BUTTON_PRESS:
+		if (event->button.button == 1)
+			activate_entry (entry);
+		return TRUE;
+	default:
+		return FALSE;
+	}
+}
+
+static void
+panel_addto_select_first_entry (PanelAddtoCanvas *canvas)
+{
+	PanelAddtoCategory      *category;
+	PanelAddtoEntry         *entry;
+	PanelAddtoCanvasPrivate *priv;
+	EntryInfo               *ei;
+
+	priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+
+	category = g_slist_nth_data (priv->info->categories, 0);
+	entry = g_slist_nth_data (category->entries, 0);
+	ei = entry->user_data;
+	if (!ei->visible) {
+		panel_addto_select_east_entry (ei, canvas);
+		return;
+	}
+	select_entry (canvas, entry);
+}
+
+static gint
+panel_addto_count_visible_entries (PanelAddtoCategory *category)
+{
+	GSList          *l;
+	PanelAddtoEntry *entry;
+	EntryInfo       *ei;
+	gint n_visible_entries = 0;
+
+	for (l = category->entries; l; l = l->next) {
+		entry = l->data;
+		ei = entry->user_data;
+		if (ei->visible)
+			n_visible_entries++;
+	}
+	return n_visible_entries;
+}
+
+static gint
+panel_addto_get_rank_of_nth_visible_entry (PanelAddtoCategory *category, gint n)
+{
+	GSList          *l;
+	PanelAddtoEntry *entry;
+	EntryInfo       *ei;
+	gint             seen_visible_entries = 0;
+	gint             seen_entries = 0;
+	gint             farthest_visible_entry = 0;
+
+	l = category->entries;
+
+	while (seen_visible_entries < n) {
+		if (!l) break;
+		seen_entries++;
+		entry = l->data;
+		ei = entry->user_data;
+		if (ei->visible) {
+			seen_visible_entries++;
+			farthest_visible_entry = seen_entries;
+		}
+		l = l->next;
+	}
+	
+	return (farthest_visible_entry - 1);
+}
+
+static gint
+panel_addto_how_many_visible_entries_before_me (PanelAddtoCategory *category, gint rank)
+{
+	GSList          *l;
+	PanelAddtoEntry *entry;
+	EntryInfo       *ei;
+	gint             seen_entries = 0;
+	gint             seen_visible_entries = 0;
+
+	l = category->entries;
+	while (seen_entries < rank) {
+		entry = l->data;
+		ei = entry->user_data;
+		if (ei->visible)
+			seen_visible_entries++;
+		l = l->next;
+		seen_entries++;
+	}
+	return seen_visible_entries;
+}
+
+static void
+panel_addto_select_east_entry (EntryInfo *ei, PanelAddtoCanvas *canvas)
+{
+	gint                     n_category, n_entry;
+	gint                     n_categories;
+	PanelAddtoEntry         *entry;
+	PanelAddtoCategory      *category;
+	PanelAddtoCanvasPrivate *priv;
+	
+	priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+	
+	n_entry = 0;
+	n_category = 0;
+	n_categories = priv->info->n_categories;
+	
+	if (ei) {
+		n_category = ei->n_category;
+		category = g_slist_nth_data (priv->info->categories, n_category);
+		if (ei->n_entry == category->n_entries - 1) {
+			if (n_category == priv->info->n_categories - 1)
+				return;
+			category = g_slist_nth_data (priv->info->categories, ei->n_category + 1);
+			entry = g_slist_nth_data (category->entries, 0);
+			ei = entry->user_data;
+			if (!ei->visible) {
+				panel_addto_select_east_entry (ei, canvas);
+				return;
+			}
+		}
+		else {
+			entry = g_slist_nth_data (category->entries, ei->n_entry + 1);
+			ei = entry->user_data;
+			if (!ei->visible) {
+				panel_addto_select_east_entry (ei, canvas);
+				return;
+			}			
+		}
+		select_entry (canvas, entry);
+	} else
+		panel_addto_select_first_entry (canvas);
+}
+
+static void
+panel_addto_select_west_entry (EntryInfo *ei, PanelAddtoCanvas *canvas)
+{
+	gint                     n_category, n_entry;
+	gint                     n_categories;
+	PanelAddtoEntry         *entry;
+	PanelAddtoCategory      *category;
+	PanelAddtoCanvasPrivate *priv;
+	
+	priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+	
+	n_entry = 0;
+	n_category = 0;
+	n_categories = priv->info->n_categories;
+	
+	if (ei) {
+		n_category = ei->n_category;
+		category = g_slist_nth_data (priv->info->categories, n_category);
+		if (ei->n_entry == 0) {
+			if (n_category == 0)
+				return;
+			category = g_slist_nth_data (priv->info->categories, ei->n_category - 1);
+			entry = g_slist_nth_data (category->entries, category->n_entries - 1);
+			ei = entry->user_data;
+			if (!ei->visible) {
+				panel_addto_select_west_entry (ei, canvas);
+				return;
+			}
+		} else {
+			entry = g_slist_nth_data (category->entries, ei->n_entry - 1);
+			ei = entry->user_data;
+			if (!ei->visible) {
+				panel_addto_select_west_entry (ei, canvas);
+				return;
+			}
+		}
+		select_entry (canvas, entry);
+	} else
+		panel_addto_select_first_entry (canvas);
+}
+
+static void
+panel_addto_select_north_entry (EntryInfo *ei, PanelAddtoCanvas *canvas)
+{
+	gint                     n_category = 0;
+	gint                     n_categories;
+	gint                     n_visible_entries = 0;
+	gint                     n_visible_entries_before_me = 0;
+	PanelAddtoEntry         *entry;
+	PanelAddtoCategory      *category;
+	PanelAddtoCanvasPrivate *priv;
+	CategoryInfo            *catinfo;
+	
+	priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+	
+	n_categories = priv->info->n_categories;
+	
+	if (ei) {
+		n_category = ei->n_category;
+		category = g_slist_nth_data (priv->info->categories, n_category);
+		n_visible_entries_before_me =
+				panel_addto_how_many_visible_entries_before_me (category, ei->n_entry);
+		if (n_visible_entries_before_me + 1 - priv->items_per_row <= 0) {
+			if (n_category == 0) {
+				panel_addto_select_first_entry (canvas);
+				return;
+			}
+			n_category--;
+			category = g_slist_nth_data (priv->info->categories, n_category);
+			catinfo = category->user_data;
+			if (!catinfo->visible) {
+				while (!catinfo->visible) {
+					category = g_slist_nth_data (priv->info->categories, --n_category);
+					if (!category)
+						return;
+					catinfo = category->user_data;
+					if (!catinfo)
+						return;
+				}
+			}
+			n_visible_entries = panel_addto_count_visible_entries (category);
+			entry = g_slist_nth_data (category->entries, 
+						  panel_addto_get_rank_of_nth_visible_entry 
+						  (category,
+						   ((n_visible_entries - 1) / priv->items_per_row) * priv->items_per_row
+						   + ((n_visible_entries_before_me + 1) % priv->items_per_row)));
+			if (!entry)
+				entry = g_slist_nth_data (category->entries, n_visible_entries - 1);
+			ei = entry->user_data;
+			if (!ei->visible) {
+				panel_addto_select_east_entry (ei, canvas);
+				return;
+			}
+		} else {
+			entry = g_slist_nth_data (category->entries, ei->n_entry - priv->items_per_row);
+			ei = entry->user_data;
+			if (!ei->visible) {
+				panel_addto_select_east_entry (ei, canvas);
+				return;
+			}
+		}
+		select_entry (canvas, entry);
+	} else
+		panel_addto_select_first_entry (canvas);
+}
+
+static void
+panel_addto_select_south_entry (EntryInfo *ei, PanelAddtoCanvas *canvas)
+{
+	gint                     n_category = 0;
+	gint                     n_categories;
+	gint                     n_visible_entries = 0;
+	gint                     n_visible_entries_before_me = 0;
+	PanelAddtoEntry         *entry;
+	PanelAddtoCategory      *category;
+	PanelAddtoCanvasPrivate *priv;
+	CategoryInfo            *catinfo;
+	
+	priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+	
+	n_categories = priv->info->n_categories;
+
+	if (ei) {
+		n_category = ei->n_category;
+		category = g_slist_nth_data (priv->info->categories, n_category);
+		n_visible_entries_before_me =
+				panel_addto_how_many_visible_entries_before_me (category, ei->n_entry);
+		n_visible_entries = panel_addto_count_visible_entries (category);
+		if (n_visible_entries_before_me + 1 + priv->items_per_row > n_visible_entries - 1) {
+			if (n_visible_entries_before_me + 1 
+			    <= ((n_visible_entries - 1) / priv->items_per_row) * priv->items_per_row) {
+				entry = g_slist_nth_data (category->entries, n_visible_entries - 1);
+			} else {
+				if (n_category == priv->info->n_categories - 1)
+					return;
+				n_category++;
+				category = g_slist_nth_data (priv->info->categories, n_category);
+				catinfo = category->user_data;
+				n_visible_entries = panel_addto_count_visible_entries (category);
+				entry = g_slist_nth_data (category->entries, ei->n_entry % priv->items_per_row);
+				if (!catinfo->visible) {
+					while (!catinfo->visible) {
+						category = g_slist_nth_data (priv->info->categories, ++n_category);
+						if (!category)
+							return;
+						catinfo = category->user_data;
+						if (!catinfo)
+							return;
+					}
+				}
+				n_visible_entries = panel_addto_count_visible_entries (category);
+				entry = g_slist_nth_data (category->entries, 
+							  panel_addto_get_rank_of_nth_visible_entry 
+							  (category,
+							   (n_visible_entries_before_me + 1) % priv->items_per_row));
+				
+				if (!entry)
+					entry = g_slist_nth_data (category->entries, n_visible_entries - 1);
+			}
+			ei = entry->user_data;
+			if (!ei->visible) {
+				panel_addto_select_east_entry (ei, canvas);
+				return;
+			}			
+		} else {
+			entry = g_slist_nth_data (category->entries, ei->n_entry + priv->items_per_row);
+			ei = entry->user_data;
+			if (!ei->visible) {
+				panel_addto_select_east_entry (ei, canvas);
+				return;
+			}
+		}
+		select_entry (canvas, entry);
+	} else
+		panel_addto_select_first_entry (canvas);
+}
+
+static gboolean
+cb_canvas_event (GnomeCanvasItem *item, GdkEvent *event, PanelAddtoDialog *dialog)
+{
+	PanelAddtoCanvas        *canvas = (PanelAddtoCanvas *) dialog->canvas;
+	PanelAddtoCanvasPrivate *priv;
+	PanelAddtoCategory      *current_category;
+	EntryInfo               *ei = NULL;
+	gint                     n_category, n_entry;
+	gint                     n_categories, n_entries;
+
+	priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+	
+	if (event->type == GDK_BUTTON_PRESS) {
+		gtk_drag_source_unset (GTK_WIDGET (canvas));
+		select_entry (canvas, NULL);
+		gtk_widget_grab_focus (GTK_WIDGET (dialog->canvas));
+		return TRUE;
+	}
+
+	if (event->type != GDK_KEY_PRESS)
+		return FALSE;
+
+	n_entry = 0;
+	n_category = 0;
+	n_categories = priv->info->n_categories;
+
+	if (priv->selected) {
+		ei = priv->selected->user_data;
+		current_category = g_slist_nth_data (priv->info->categories, ei->n_category);
+		n_entries = current_category->n_entries;
+	}
+
+	switch (event->key.keyval) {
+	case GDK_KP_Right:
+	case GDK_Right:
+		if (priv->rtl)
+			panel_addto_select_west_entry (ei, canvas);
+		else
+			panel_addto_select_east_entry (ei, canvas);
+		return TRUE;
+	case GDK_KP_Left:
+	case GDK_Left:
+		if (priv->rtl)
+			panel_addto_select_east_entry (ei, canvas);
+		else
+			panel_addto_select_west_entry (ei, canvas);
+		return TRUE;
+	case GDK_KP_Down:
+	case GDK_Down:
+		panel_addto_select_south_entry (ei, canvas);
+		return TRUE;
+	case GDK_KP_Up:
+	case GDK_Up:
+		panel_addto_select_north_entry (ei, canvas);
+		return TRUE;
+	case GDK_Tab:
+	case GDK_KP_Tab:
+	case GDK_ISO_Left_Tab:
+		gtk_widget_grab_focus (dialog->search_entry);
+		break;
+	case GDK_Return:
+	case GDK_KP_Enter:
+		if (priv->selected)
+			activate_entry (priv->selected);
+
+		return TRUE;
+		break;
+	case GDK_Escape:
+		panel_addto_dialog_response (dialog->addto_dialog,
+					     GTK_RESPONSE_CANCEL,
+					     dialog);
+		return TRUE;
+	default:
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+
+static void
+calculate_item_width (PanelAddtoCanvas *canvas, EntryInfo *ei)
+{
+	PanelAddtoCanvasPrivate *priv;
+	PangoLayout *layout;
+	PangoRectangle rectangle;
+
+	priv   = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+	layout = GNOME_CANVAS_TEXT (ei->text)->layout;
+
+	pango_layout_set_wrap (layout, PANGO_WRAP_WORD_CHAR);
+	pango_layout_set_width (layout, -1);
+	pango_layout_get_pixel_extents (layout, NULL, &rectangle);
+
+	/* If its too big wrap at the max and regen to find the layout */
+	if (rectangle.width > MAX_ITEM_WIDTH) {
+		pango_layout_set_width (layout, MAX_ITEM_WIDTH * PANGO_SCALE);
+		pango_layout_get_pixel_extents (layout, NULL, &rectangle);
+		rectangle.width = MAX_ITEM_WIDTH;
+	}
+
+	ei->text_height = rectangle.height;
+
+	priv->max_item_width = MAX (priv->max_item_width, rectangle.width);
+}
+
+static void
+calculate_item_height (PanelAddtoCanvas *canvas, EntryInfo *ei)
+{
+	PanelAddtoCanvasPrivate *priv;
+	gint item_height;
+
+	priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+
+	if (ei->pixbuf)
+		priv->max_icon_height = MAX (priv->max_icon_height, ei->icon_height);
+
+	item_height = ei->icon_height + ei->text_height;
+	priv->max_item_height = MAX (priv->max_item_height, item_height);
+}
+
+static void
+calculate_sizes (PanelAddtoCanvas *canvas)
+{
+	GSList                  *l, *m;
+	PanelAddtoCanvasPrivate *priv;
+	PanelAddtoCategory      *current_category;
+	PanelAddtoEntry         *current_entry;
+
+	priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+	priv->max_item_height = 0;
+	priv->max_icon_height = 0;
+	priv->max_item_width  = 0;
+
+	for (l = priv->info->categories; l; l = l->next) {
+		current_category = l->data;
+		for (m = current_category->entries; m; m = m->next) {
+			current_entry = m->data;
+			EntryInfo *ei = current_entry->user_data;
+			calculate_item_width  (canvas, ei);
+			calculate_item_height (canvas, ei);
+		}
+	}
+}
+
+static void
+gnome_canvas_item_move_absolute (GnomeCanvasItem *item, double dx, double dy)
+{
+	double translate[6];
+
+	g_return_if_fail (item != NULL);
+	g_return_if_fail (GNOME_IS_CANVAS_ITEM (item));
+
+	art_affine_translate (translate, dx, dy);
+
+	gnome_canvas_item_affine_absolute (item, translate);
+}
+
+static guchar
+lighten_component (guchar cur_value)
+{
+	int new_value = cur_value;
+	new_value += 24 + (new_value >> 3);
+	if (new_value > 255) {
+		new_value = 255;
+	}
+	return (guchar) new_value;
+}
+
+static GdkPixbuf *
+create_spotlight_pixbuf (GdkPixbuf* src)
+{
+	GdkPixbuf *dest;
+	int i, j;
+	int width, height, has_alpha, src_row_stride, dst_row_stride;
+	guchar *target_pixels, *original_pixels;
+	guchar *pixsrc, *pixdest;
+
+	g_return_val_if_fail (gdk_pixbuf_get_colorspace (src) == GDK_COLORSPACE_RGB, NULL);
+	g_return_val_if_fail ((!gdk_pixbuf_get_has_alpha (src)
+			       && gdk_pixbuf_get_n_channels (src) == 3)
+			      || (gdk_pixbuf_get_has_alpha (src)
+				  && gdk_pixbuf_get_n_channels (src) == 4), NULL);
+	g_return_val_if_fail (gdk_pixbuf_get_bits_per_sample (src) == 8, NULL);
+
+	dest = gdk_pixbuf_copy (src);
+
+	has_alpha = gdk_pixbuf_get_has_alpha (src);
+	width = gdk_pixbuf_get_width (src);
+	height = gdk_pixbuf_get_height (src);
+	dst_row_stride = gdk_pixbuf_get_rowstride (dest);
+	src_row_stride = gdk_pixbuf_get_rowstride (src);
+	target_pixels = gdk_pixbuf_get_pixels (dest);
+	original_pixels = gdk_pixbuf_get_pixels (src);
+
+	for (i = 0; i < height; i++) {
+		pixdest = target_pixels + i * dst_row_stride;
+		pixsrc = original_pixels + i * src_row_stride;
+		for (j = 0; j < width; j++) {
+			*pixdest++ = lighten_component (*pixsrc++);
+			*pixdest++ = lighten_component (*pixsrc++);
+			*pixdest++ = lighten_component (*pixsrc++);
+			if (has_alpha) {
+				*pixdest++ = *pixsrc++;
+			}
+		}
+	}
+
+	return dest;
+}
+
+static void
+build_canvas (PanelAddtoCanvas *canvas)
+{
+	GSList                  *l, *m;
+	EntryInfo               *ei;
+	PanelAddtoDialog        *dialog;
+	PanelAddtoCategory      *current_category = NULL;
+	PanelAddtoInformation   *current_info     = NULL;
+	PanelAddtoEntry         *current_entry    = NULL;
+	PanelAddtoCanvasPrivate *priv;
+	GnomeCanvas             *gcanvas;
+	GnomeCanvasGroup        *hidden_group;
+	int i, j, index;
+	
+	priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+	gcanvas = GNOME_CANVAS (canvas);
+	current_category = priv->info->categories->data;
+	current_entry = current_category->entries->data;
+	dialog = current_entry->dialog;
+	index = 0;
+
+	priv->under_cover = gnome_canvas_item_new (gnome_canvas_root (gcanvas),
+						   panel_addto_event_box_get_type(),
+						   NULL);
+
+	current_info = priv->info;
+	gnome_canvas_item_grab_focus (GNOME_CANVAS_ITEM (gnome_canvas_root (gcanvas)));
+	g_signal_connect (gnome_canvas_root (gcanvas), "event",
+			  G_CALLBACK (cb_canvas_event), dialog);
+
+	hidden_group =	GNOME_CANVAS_GROUP (gnome_canvas_item_new (gnome_canvas_root (gcanvas),
+								   gnome_canvas_group_get_type (),
+								   NULL));
+	for (l = priv->info->categories, i = 0; l; l = l->next, i++) {
+
+		CategoryInfo *catinfo;
+		current_category = l->data;
+
+		if (current_category->user_data == NULL)
+			current_category->user_data = g_new (CategoryInfo, 1);
+
+		catinfo = current_category->user_data;
+		catinfo->group = NULL;
+		catinfo->title = NULL;
+		catinfo->line = NULL;
+
+		catinfo->group =
+			GNOME_CANVAS_GROUP (gnome_canvas_item_new (gnome_canvas_root (gcanvas),
+								   gnome_canvas_group_get_type (),
+								   NULL));
+		gnome_canvas_item_move_absolute (GNOME_CANVAS_ITEM (catinfo->group), 0, BORDERS);
+
+		catinfo->line = gnome_canvas_item_new (catinfo->group,
+			gnome_canvas_rect_get_type (),
+			"x2", (double) priv->max_width - 2 * BORDERS,
+			"y2", (double) LINE_HEIGHT,
+			NULL);
+
+		catinfo->title = NULL;
+
+		if (current_category && (priv->info->n_categories != 1)) {
+			char *label = g_strdup_printf ("<span weight=\"bold\">%s</span>", current_category->title);
+			catinfo->title = gnome_canvas_item_new (catinfo->group,
+				gnome_canvas_text_get_type (),
+				"text", current_category->title,
+				"markup", label,
+				"anchor", GTK_ANCHOR_NW,
+				NULL);
+			g_free (label);
+		}
+
+		for (m = current_category->entries, j = 0; m; m = m->next, j++) {
+			current_entry = m->data;
+
+			if (current_entry->user_data == NULL)
+				current_entry->user_data = g_new0 (EntryInfo, 1);
+
+			ei = current_entry->user_data;
+
+			ei->canvas = canvas;
+			ei->group  = GNOME_CANVAS_GROUP (
+				gnome_canvas_item_new (catinfo->group,
+				gnome_canvas_group_get_type (),
+				NULL));
+			ei->selection = gnome_canvas_item_new (
+				ei->group,
+				PANEL_ADDTO_TYPE_ROUNDED_RECT,
+				NULL);
+
+			if (current_entry->title) {
+				ei->text = gnome_canvas_item_new (ei->group,
+					gnome_canvas_text_get_type (),
+					"anchor", GTK_ANCHOR_NW,
+					"justification", GTK_JUSTIFY_CENTER,
+					"clip",	  TRUE,
+					NULL);
+				pango_layout_set_alignment (GNOME_CANVAS_TEXT (ei->text)->layout,
+							    PANGO_ALIGN_CENTER);
+				pango_layout_set_justify (GNOME_CANVAS_TEXT (ei->text)->layout,
+							  FALSE);
+				g_object_set (ei->text,
+					      "text", current_entry->title,
+					      NULL);
+			} else
+				ei->text = NULL;
+
+			if (current_entry->icon_pixbuf) {
+				GdkPixbuf *pixbuf = current_entry->icon_pixbuf;
+				GdkPixbuf *highlight_pixbuf =
+					create_spotlight_pixbuf (pixbuf);
+
+				ei->icon_height = gdk_pixbuf_get_height (pixbuf);
+				ei->icon_width  = gdk_pixbuf_get_width (pixbuf);
+				ei->pixbuf = gnome_canvas_item_new (ei->group,
+					gnome_canvas_pixbuf_get_type (),
+					"pixbuf", pixbuf,
+					NULL);
+				g_object_unref (pixbuf);
+				ei->highlight_pixbuf = gnome_canvas_item_new (ei->group,
+					gnome_canvas_pixbuf_get_type (),
+					"pixbuf", highlight_pixbuf,
+					NULL);
+				g_object_unref (highlight_pixbuf);
+			} else {
+				ei->pixbuf = NULL;
+				ei->highlight_pixbuf = NULL;
+			}
+
+			ei->cover = gnome_canvas_item_new (ei->group,
+							   panel_addto_event_box_get_type(),
+							   NULL);
+			calculate_item_width  (canvas, ei);
+			calculate_item_height (canvas, ei);
+			
+			ei->n_category = i;
+			ei->n_entry = j;
+			ei->index = index;
+
+			setup_entry (canvas, current_entry);
+
+			g_signal_connect (ei->cover, "event",
+					  G_CALLBACK (cover_event),
+					  current_entry);
+			index++;
+		}
+	}
+
+	dialog = current_entry->dialog;
+	
+	g_signal_connect (G_OBJECT (canvas), "selection-changed",
+	                  G_CALLBACK (panel_addto_selection_changed), current_entry->dialog);
+}
+
+
+static const char *
+panel_addto_utf8_casestrstr (const char *haystack, const char *needle)
+{
+	
+	if (!haystack)
+		return NULL;
+	
+	haystack = g_utf8_strdown (haystack, -1);
+	needle   = g_utf8_strdown (needle, -1);
+	
+	const char *s;
+	gsize       i;
+	gsize       haystack_len = g_utf8_strlen (haystack, -1);
+	gsize       needle_len = g_utf8_strlen (needle, -1);
+	int         needle_size = strlen (needle);
+	
+	if (needle_len > haystack_len)
+		return NULL;
+	
+	s = haystack;
+	for (i = 0; i <= haystack_len - needle_len; i++) {
+		if (strncmp (s, needle, needle_size) == 0)
+			return s;
+		s = g_utf8_next_char (s);
+	}
+	
+	return NULL;
+}
+
+void
+panel_addto_relayout_for_search (GtkWidget *search_entry, PanelAddtoDialog *dialog)
+{
+	gchar                   *search_text;
+	PanelAddtoCanvasPrivate *priv;
+
+	search_text = g_malloc (strlen ((gchar*) gtk_entry_get_text (GTK_ENTRY (search_entry))) + 1);
+	g_stpcpy (search_text, gtk_entry_get_text (GTK_ENTRY (search_entry)));
+	g_strchomp (search_text);
+	if (dialog->canvas) {
+		priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (dialog->canvas);
+		priv->search_text = search_text;
+		gtk_widget_queue_resize (GTK_WIDGET (dialog->canvas));
+	}
+}
+
+void
+panel_addto_activate_from_searchbar (GtkWidget *search_entry, PanelAddtoDialog *dialog)
+{
+	PanelAddtoCanvasPrivate *priv;
+
+	priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (dialog->canvas);
+	if (priv->selected)
+		activate_entry (priv->selected);
+}
+
+/* If we can't find the search query in the applet's name, in the applet's
+ * description, nor in the applet's category, then the applet has to be hidden.
+ */
+
+static gboolean
+panel_addto_entry_must_be_hidden (PanelAddtoEntry *entry, const gchar **search_terms)
+{
+	gint i;
+	gint nb_search_terms = 0, nb_found = 0;
+	gboolean search_is_null = TRUE;
+	
+	for (i = 0; search_terms[i] != NULL; i++) {
+		nb_search_terms ++;
+		search_is_null = FALSE;
+		if (
+		    (entry->title 
+		     && panel_addto_utf8_casestrstr (g_locale_to_utf8 (entry->title, -1, NULL, NULL, NULL),
+						     g_locale_to_utf8 (search_terms[i], -1, NULL, NULL, NULL)))
+		    || (entry->comment 
+			&& panel_addto_utf8_casestrstr (g_locale_to_utf8 (entry->comment, -1, NULL, NULL, NULL),
+							g_locale_to_utf8 (search_terms[i], -1, NULL, NULL, NULL)))
+		    || (entry->category->title 
+			&& panel_addto_utf8_casestrstr (g_locale_to_utf8 (entry->category->title, -1, NULL, NULL, NULL),
+							g_locale_to_utf8 (search_terms[i], -1, NULL, NULL, NULL))))
+			nb_found++;
+	}
+
+	if (search_is_null || nb_found == nb_search_terms)
+		return FALSE;
+
+	return TRUE;
+}
+
+/* A category canvas item contains all the elements
+ * for the category, as well as the title and a separator
+ */
+static void
+relayout_category (PanelAddtoCanvas *canvas, CategoryInfo *catinfo,
+		   gint vert_pos, gint *category_vert_pos)
+{
+	PanelAddtoCanvasPrivate *priv;
+
+	priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+	gnome_canvas_item_move_absolute (GNOME_CANVAS_ITEM (catinfo->group),
+					 0, vert_pos);
+
+	if (catinfo->line) {
+		gnome_canvas_item_move_absolute (catinfo->line, BORDERS, ABOVE_LINE_SPACING);
+
+		gnome_canvas_item_set (catinfo->line,
+				       "x2", (double) priv->max_width - 2 * BORDERS,
+				       "y2", (double) LINE_HEIGHT,
+				       NULL);
+	}
+
+	if (catinfo->title) {
+		double text_height, text_width;
+
+		g_object_get (catinfo->title,
+			      "text_height", &text_height,
+			      "text_width",  &text_width,
+			      NULL);
+
+		*category_vert_pos += text_height; /* move it down 1 line */
+		gnome_canvas_item_move_absolute (catinfo->title,
+						 (priv->rtl) ? priv->max_width - BORDERS - text_width : BORDERS,
+						 *category_vert_pos);
+		*category_vert_pos += text_height + text_height/2 + UNDER_TITLE_SPACING;
+	}
+}
+
+static void
+relayout_item (PanelAddtoCanvas *canvas, EntryInfo *ei,
+	       gint category_horiz_pos, gint category_vert_pos)
+{
+	PanelAddtoCanvasPrivate *priv;
+
+	priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+
+	gnome_canvas_item_move_absolute (GNOME_CANVAS_ITEM (ei->group),
+					 category_horiz_pos,
+					 category_vert_pos);
+
+	gnome_canvas_item_set (ei->selection,
+			       "x2", (double) priv->max_item_width + 2 * PAD,
+			       "y2", (double) ei->text_height + 1, /* expand it down slightly */
+			       NULL);
+
+	gnome_canvas_item_move_absolute (ei->selection, -PAD, priv->max_icon_height);
+
+	if (ei->text) {
+		/* canvas asks layout for its extent, layout gives real
+		 * size, not fixed width and drawing gets confused.
+		 */
+		gnome_canvas_item_set (ei->text,
+				       "clip_width",  (double) priv->max_item_width,
+				       "clip_height", (double) priv->max_item_height,
+				       NULL);
+
+		/* text is centered by pango */
+		pango_layout_set_width (GNOME_CANVAS_TEXT (ei->text)->layout,
+					(gint) priv->max_item_width * PANGO_SCALE);
+
+		gnome_canvas_item_move_absolute (ei->text,
+						 0, priv->max_icon_height);
+	}
+
+	if (ei->pixbuf) {
+		/* manually center the icon */
+		gnome_canvas_item_move_absolute (ei->pixbuf,
+						 priv->max_item_width / 2 - ei->icon_width / 2, 0);
+		gnome_canvas_item_move_absolute (ei->highlight_pixbuf,
+						 priv->max_item_width / 2 - ei->icon_width / 2, 0);
+	}
+
+	/* cover the item */
+	gnome_canvas_item_set (ei->cover,
+			       "x2", (double) priv->max_item_width,
+			       "y2", (double) priv->max_item_height,
+			       NULL);
+}
+
+static void
+relayout_canvas (PanelAddtoCanvas *canvas)
+{
+	gint                    entry;
+	gint                    vert_pos, category_vert_pos, category_horiz_pos;
+	gint                    real_width;
+	PanelAddtoCanvasPrivate *priv;
+	PanelAddtoCategory      *current_category;
+	PanelAddtoEntry         *current_entry;
+	CategoryInfo            *catinfo;
+	EntryInfo               *ei;
+	GSList                  *l, *m;
+	gboolean                 at_least_one_found, first_shown_category, first_shown_entry;
+
+	priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+	real_width = priv->max_width - 2 * BORDERS + ITEMS_SEPARATION;
+	priv->items_per_row = real_width / ((gint) priv->max_item_width + ITEMS_SEPARATION);
+
+	vert_pos = BORDERS;
+
+	const gchar *search_text = priv->search_text;
+	gchar **search_terms;
+	search_terms = search_text ? g_strsplit (search_text, " ", 0) : NULL;
+
+	first_shown_category = TRUE;
+	first_shown_entry    = TRUE;
+
+	for (l = priv->info->categories; l; l = l->next) {
+
+		at_least_one_found = FALSE;
+		category_vert_pos = 0;
+
+		category_horiz_pos = (priv->rtl) ? priv->max_width - (gint) priv->max_item_width - BORDERS : BORDERS;
+
+		current_category = l->data;
+		catinfo  = current_category->user_data;
+
+		relayout_category (canvas, catinfo, vert_pos, &category_vert_pos);
+		category_vert_pos += UNDER_LINE_SPACING;
+
+		for (m = current_category->entries, entry = 0; m; m = m->next, entry++) {
+
+			current_entry = m->data;
+			ei = current_entry->user_data;
+
+			/* we don't want the first item to wrap, it would
+			   be too separated from the section title */
+
+			if (!search_text || !panel_addto_entry_must_be_hidden (current_entry, (const gchar **)search_terms)) {
+				at_least_one_found = TRUE;
+				gnome_canvas_item_show (GNOME_CANVAS_ITEM (ei->group));
+				ei->visible = TRUE;
+				if ((entry > 0) &&
+				    ((priv->items_per_row == 0) ||
+				     (priv->items_per_row > 0 && (entry % priv->items_per_row == 0)))) {
+					
+					category_horiz_pos = (priv->rtl) ?
+						priv->max_width - (gint) priv->max_item_width - BORDERS : BORDERS;
+					category_vert_pos  += (gint) priv->max_item_height + ITEMS_SEPARATION;
+				}
+				
+				relayout_item (canvas, ei, category_horiz_pos, category_vert_pos);
+				
+				if (priv->rtl)
+					category_horiz_pos -= (gint) priv->max_item_width + ITEMS_SEPARATION;
+				else
+					category_horiz_pos += (gint) priv->max_item_width + ITEMS_SEPARATION;
+				
+				/* If the user is actually using the search bar, select
+				 * the first shown entry.
+				 */
+				if (search_text && first_shown_entry) {
+					select_entry (canvas, current_entry);
+					first_shown_entry = FALSE;
+				}
+			} else {
+				gnome_canvas_item_hide (GNOME_CANVAS_ITEM (ei->group));
+				ei->visible = FALSE;
+				entry --;
+			}
+			
+		}
+		if (at_least_one_found) {
+			gnome_canvas_item_show (GNOME_CANVAS_ITEM (catinfo->group));
+			catinfo->visible = TRUE;
+			category_vert_pos += (gint) priv->max_item_height;
+			vert_pos += category_vert_pos + ITEMS_SEPARATION;
+
+			if (first_shown_category) {
+				g_object_set (catinfo->line,
+					      "x2", (double) priv->max_width - 2 * BORDERS,
+					      "y2", (double) 0,
+					      NULL);
+				first_shown_category = FALSE;
+			} else {
+				g_object_set (catinfo->line,
+					      "x2", (double) priv->max_width - 2 * BORDERS,
+					      "y2", (double) LINE_HEIGHT,
+					      NULL);
+			}
+			
+		} else {
+			gnome_canvas_item_hide (GNOME_CANVAS_ITEM (catinfo->group));
+			catinfo->visible = FALSE;
+		}
+	}
+	
+	/* substract the last ITEMS_SEPARATION to
+	   adjust the canvas size a bit more */
+	vert_pos -= ITEMS_SEPARATION;
+
+	priv->height = MAX (vert_pos, priv->min_height);
+	priv->width  = priv->max_width;
+}
+
+
+static void
+set_style (PanelAddtoCanvas *canvas, gboolean font_changed)
+{
+	GSList                  *l, *m;
+	PanelAddtoCategory      *current_category;
+	PanelAddtoEntry         *current_entry;
+	PanelAddtoCanvasPrivate *priv;
+	GtkWidget               *widget = GTK_WIDGET (canvas);
+
+
+	if (!GTK_WIDGET_REALIZED (widget))
+		return;
+
+	priv = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+
+	for (l = priv->info->categories; l; l = l->next) {
+		current_category = l->data;
+		CategoryInfo *catinfo = current_category->user_data;
+
+		if (catinfo->line) {
+			g_object_set (catinfo->line,
+				      "fill_color_gdk", &widget->style->text_aa[GTK_STATE_NORMAL],
+				      NULL);
+		}
+		if (catinfo->title) {
+			g_object_set (catinfo->title,
+				      "fill_color_gdk", &widget->style->text[GTK_STATE_NORMAL],
+				      NULL);
+
+			if (font_changed)
+				g_object_set (catinfo->title,
+					      "font", NULL,
+					      NULL);
+		}
+
+		for (m = current_category->entries; m; m = m->next) {
+			current_entry = m->data;
+			EntryInfo *entryinfo = current_entry->user_data;
+			if (font_changed && entryinfo->text)
+				g_object_set (entryinfo->text,
+					      "font", NULL,
+					      NULL);
+			setup_entry (canvas, current_entry);
+		}
+	}
+
+	if (font_changed) {
+		calculate_sizes (canvas);
+		relayout_canvas (canvas);
+	}
+}
+
+
+GtkWidget*
+panel_addto_canvas_new (PanelAddtoInformation *info)
+{
+	
+	return g_object_new (PANEL_ADDTO_TYPE_CANVAS,
+			     "info", info,
+			     NULL);
+}
+
+/* Accessibility support */
+
+static gpointer accessible_parent_class;
+static gpointer accessible_item_parent_class;
+
+enum {
+	ACTION_ACTIVATE,
+	LAST_ACTION
+};
+
+typedef struct {
+	AtkObject parent;
+
+	PanelAddtoEntry *entry;
+	AtkStateSet *state_set;
+
+	guint action_idle_handler;
+} PanelAddtoCanvasItemAccessible;
+
+typedef struct {
+	AtkObjectClass parent_class;
+} PanelAddtoCanvasItemAccessibleClass;
+
+static const gchar *const action_names[] = 
+{
+	"activate",
+	NULL
+};
+
+static const gchar *const action_descriptions[] =
+{
+	"Activate item",
+	NULL
+};
+
+static void
+panel_addto_canvas_item_accessible_get_extents (AtkComponent *component,
+					    gint         *x,
+					    gint         *y,
+					    gint         *width,
+					    gint         *height,
+					    AtkCoordType  coord_type)
+{
+	PanelAddtoCanvasItemAccessible *item;
+	PanelAddtoCanvas *canvas;
+	GnomeCanvasItem *cover;
+	AtkObject *parent_object;
+	gint p_x, p_y;
+
+	item = (PanelAddtoCanvasItemAccessible *) component;
+
+	canvas = ((EntryInfo *) item->entry->user_data)->canvas;
+	parent_object = gtk_widget_get_accessible (GTK_WIDGET (canvas));
+	atk_component_get_position (ATK_COMPONENT (parent_object), &p_x, &p_y, coord_type);
+
+
+	/* the cover pretty much represents the item size */
+
+
+	cover = GNOME_CANVAS_ITEM (((EntryInfo *)item->entry->user_data)->cover);
+
+	*x = p_x + cover->x1;
+	*y = p_y + cover->y1;
+	*width  = cover->x2 - cover->x1;
+	*height = cover->y2 - cover->y1;
+}
+
+static void
+atk_component_item_interface_init (AtkComponentIface *iface)
+{
+	iface->get_extents = panel_addto_canvas_item_accessible_get_extents;
+}
+
+static gboolean
+idle_do_action (gpointer data)
+{
+	PanelAddtoCanvasItemAccessible *item;
+
+	item = (PanelAddtoCanvasItemAccessible *) data;
+
+	item->action_idle_handler = 0;
+	activate_entry (item->entry);
+
+	return FALSE;
+}
+
+
+static gboolean
+panel_addto_canvas_item_accessible_action_do_action (AtkAction *action,
+						 gint       index)
+{
+	PanelAddtoCanvasItemAccessible *item;
+
+	if (index < 0 || index >= LAST_ACTION) 
+		return FALSE;
+
+	item = (PanelAddtoCanvasItemAccessible *) action;
+
+	switch (index) {
+	case ACTION_ACTIVATE:
+		if (!item->action_idle_handler)
+			item->action_idle_handler = g_idle_add (idle_do_action, item);
+		break;
+	default:
+		g_assert_not_reached ();
+		return FALSE;
+	}        
+
+	return TRUE;
+}
+
+static gint
+panel_addto_canvas_item_accessible_action_get_n_actions (AtkAction *action)
+{
+        return LAST_ACTION;
+}
+
+static const gchar *
+panel_addto_canvas_item_accessible_action_get_description (AtkAction *action,
+                                                      gint       index)
+{
+	if (index < 0 || index >= LAST_ACTION) 
+		return NULL;
+
+	return action_descriptions[index];
+}
+
+static const gchar *
+panel_addto_canvas_item_accessible_action_get_name (AtkAction *action,
+                                               gint       index)
+{
+	if (index < 0 || index >= LAST_ACTION) 
+		return NULL;
+
+	return action_names[index];
+}
+
+static void
+atk_action_item_interface_init (AtkActionIface *iface)
+{
+	iface->do_action = panel_addto_canvas_item_accessible_action_do_action;
+	iface->get_n_actions = panel_addto_canvas_item_accessible_action_get_n_actions;
+	iface->get_description = panel_addto_canvas_item_accessible_action_get_description;
+	iface->get_name = panel_addto_canvas_item_accessible_action_get_name;
+}
+
+static gint
+panel_addto_canvas_item_accessible_get_index_in_parent (AtkObject *object)
+{
+	PanelAddtoCanvasItemAccessible *item;
+
+	item = (PanelAddtoCanvasItemAccessible *) object;
+
+	return ((EntryInfo *) item->entry->user_data)->index;
+}
+
+static G_CONST_RETURN gchar*
+panel_addto_canvas_item_accessible_get_name (AtkObject *object)
+{
+	PanelAddtoCanvasItemAccessible *item;
+
+	if (object->name)
+		return object->name;
+	else {
+		item = (PanelAddtoCanvasItemAccessible *) object;
+
+		if (item->entry && item->entry->title)
+			return item->entry->title;
+		else
+			return "Item with no description";
+	}
+}
+
+static AtkObject*
+panel_addto_canvas_item_accessible_get_parent (AtkObject *object)
+{
+	PanelAddtoCanvasItemAccessible *item;
+	PanelAddtoCanvas *canvas;
+
+	item = (PanelAddtoCanvasItemAccessible *) object;
+	canvas = ((EntryInfo *) item->entry->user_data)->canvas;
+
+	return gtk_widget_get_accessible (GTK_WIDGET (canvas));
+}
+
+static AtkStateSet*
+panel_addto_canvas_item_accessible_ref_state_set (AtkObject *object)
+{
+	PanelAddtoCanvasItemAccessible *item;
+	PanelAddtoCanvasPrivate *priv;
+	PanelAddtoCanvas *canvas;
+
+	item   = (PanelAddtoCanvasItemAccessible *) object;
+	canvas = ((EntryInfo *) item->entry->user_data)->canvas;
+	priv   = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+
+	if (item->entry == priv->selected)
+		atk_state_set_add_state (item->state_set, ATK_STATE_FOCUSED);
+	else
+		atk_state_set_remove_state (item->state_set, ATK_STATE_FOCUSED);
+
+	return g_object_ref (item->state_set);
+}
+
+static void
+panel_addto_canvas_item_accessible_class_init (AtkObjectClass *class)
+{
+	GObjectClass *object_class;
+
+	accessible_item_parent_class = g_type_class_peek_parent (class);
+
+	object_class = (GObjectClass *)class;
+
+	class->get_index_in_parent = panel_addto_canvas_item_accessible_get_index_in_parent; 
+	class->get_name = panel_addto_canvas_item_accessible_get_name;
+	class->get_parent = panel_addto_canvas_item_accessible_get_parent; 
+	class->ref_state_set = panel_addto_canvas_item_accessible_ref_state_set;
+}
+
+static void
+panel_addto_canvas_item_accessible_object_init (PanelAddtoCanvasItemAccessible *item)
+{
+	item->state_set = atk_state_set_new ();
+
+	atk_state_set_add_state (item->state_set, ATK_STATE_ENABLED);
+	atk_state_set_add_state (item->state_set, ATK_STATE_FOCUSABLE);
+	atk_state_set_add_state (item->state_set, ATK_STATE_SENSITIVE);
+	atk_state_set_add_state (item->state_set, ATK_STATE_SELECTABLE);
+	atk_state_set_add_state (item->state_set, ATK_STATE_VISIBLE);
+
+	item->action_idle_handler = 0;
+}
+
+static GType
+panel_addto_canvas_item_accessible_get_type (void)
+{
+	static GType type = 0;
+
+	if (type == 0) {
+		static const GTypeInfo info = {
+			sizeof (PanelAddtoCanvasItemAccessibleClass),
+			(GBaseInitFunc) NULL, /* base init */
+			(GBaseFinalizeFunc) NULL, /* base finalize */
+			(GClassInitFunc) panel_addto_canvas_item_accessible_class_init, /* class init */
+			(GClassFinalizeFunc) NULL, /* class finalize */
+			NULL, /* class data */
+			sizeof (PanelAddtoCanvasItemAccessible), /* instance size */
+			0, /* nb preallocs */
+			(GInstanceInitFunc) panel_addto_canvas_item_accessible_object_init, /* instance init */
+			NULL /* value table */
+		};
+
+		static const GInterfaceInfo atk_component_info = {
+			(GInterfaceInitFunc) atk_component_item_interface_init,
+			(GInterfaceFinalizeFunc) NULL,
+			NULL
+		};
+
+		static const GInterfaceInfo atk_action_info = {
+			(GInterfaceInitFunc) atk_action_item_interface_init,
+			(GInterfaceFinalizeFunc) NULL,
+			NULL
+		};
+
+		type = g_type_register_static (ATK_TYPE_OBJECT,
+					       "PanelAddtoCanvasItemAccessible", &info, 0);
+
+		g_type_add_interface_static (type, ATK_TYPE_COMPONENT,
+					     &atk_component_info);
+		g_type_add_interface_static (type, ATK_TYPE_ACTION,
+					     &atk_action_info);
+	}
+
+	return type;
+}
+
+static gint
+panel_addto_canvas_accessible_get_n_children (AtkObject *accessible)
+{
+	GSList                  *l;
+	PanelAddtoCategory      *current_category;
+	PanelAddtoCanvasPrivate *priv;
+	PanelAddtoCanvas        *canvas;
+	GtkWidget               *widget;
+	gint count;
+
+	widget = GTK_ACCESSIBLE (accessible)->widget;
+
+	if (!widget)
+		return 0;
+
+	canvas = PANEL_ADDTO_CANVAS (widget);
+	priv   = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+	count  = 0;
+
+	for (l = priv->info->categories; l; l = l->next) {
+		current_category = l->data;
+		count += current_category->n_entries;
+	}
+
+	return count;
+}
+
+static PanelAddtoEntry*
+panel_addto_canvas_accessible_get_entry (PanelAddtoCanvas *canvas, gint index)
+{
+	GSList                  *l;
+	PanelAddtoCanvasPrivate *priv;
+	PanelAddtoCategory      *current_category;
+	gint count;
+
+	priv  = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+	count = 0;
+	
+	for (l = priv->info->categories; l; l = l->next) {
+		current_category = l->data;
+		if (index >= count &&
+		    index < count + current_category->n_entries) {
+			return g_slist_nth_data (current_category->entries, index - count);
+		} else
+			count += current_category->n_entries;
+	}
+
+	return NULL;
+}
+
+static AtkObject*
+panel_addto_canvas_accessible_ref_child (AtkObject *accessible, gint index)
+{
+	PanelAddtoCanvasItemAccessible *item;
+	PanelAddtoEntry *entry;
+	PanelAddtoCanvasPrivate *priv;
+	PanelAddtoCanvas *canvas;
+	GtkWidget *widget;
+	AtkObject *object;
+
+	widget = GTK_ACCESSIBLE (accessible)->widget;
+
+	if (!widget)
+		return NULL;
+
+	canvas = PANEL_ADDTO_CANVAS (widget);
+	priv   = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+	entry  = panel_addto_canvas_accessible_get_entry (canvas, index);
+
+	if (!entry)
+		return NULL;
+
+	object = g_hash_table_lookup (priv->accessible_children, &index);
+
+	if (!object) {
+		object = g_object_new (panel_addto_canvas_item_accessible_get_type (), NULL);
+		item   = (PanelAddtoCanvasItemAccessible *) object;
+
+		object->role = ATK_ROLE_ICON;
+		item->entry  = entry;
+
+		g_hash_table_insert (priv->accessible_children,
+				     &((EntryInfo *) entry->user_data)->index, object);
+	}
+
+	return g_object_ref (object);
+}
+
+static void
+panel_addto_canvas_accessible_initialize (AtkObject *accessible, gpointer data)
+{
+	if (ATK_OBJECT_CLASS (accessible_parent_class)->initialize)
+		ATK_OBJECT_CLASS (accessible_parent_class)->initialize (accessible, data);
+
+	accessible->role = ATK_ROLE_LAYERED_PANE;
+}
+
+static void
+panel_addto_canvas_accessible_class_init (AtkObjectClass *class)
+{
+	GObjectClass *object_class;
+	GtkAccessibleClass *accessible_class;
+
+	accessible_parent_class = g_type_class_peek_parent (class);
+
+	object_class = (GObjectClass *)class;
+	accessible_class = (GtkAccessibleClass *)class;
+
+	class->get_n_children = panel_addto_canvas_accessible_get_n_children;
+	class->ref_child = panel_addto_canvas_accessible_ref_child;
+	class->initialize = panel_addto_canvas_accessible_initialize;
+}
+
+static gboolean
+panel_addto_canvas_accessible_add_selection (AtkSelection *selection, gint i)
+{
+	PanelAddtoCanvasPrivate *priv;
+	PanelAddtoCanvas *canvas;
+	GtkWidget *widget;
+	PanelAddtoEntry *entry;
+
+	widget = GTK_ACCESSIBLE (selection)->widget;
+
+	if (!widget)
+		return FALSE;
+
+	canvas = PANEL_ADDTO_CANVAS (widget);
+	priv   = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+
+	entry = panel_addto_canvas_accessible_get_entry (canvas, i);
+	select_entry (canvas, entry);
+
+	return TRUE;
+}
+
+static gboolean
+panel_addto_canvas_accessible_clear_selection (AtkSelection *selection)
+{
+	PanelAddtoCanvas *canvas;
+	GtkWidget *widget;
+
+	widget = GTK_ACCESSIBLE (selection)->widget;
+
+	if (!widget)
+		return FALSE;
+
+	canvas = PANEL_ADDTO_CANVAS (widget);
+	select_entry (canvas, NULL);
+
+	return TRUE;
+}
+
+static AtkObject*
+panel_addto_canvas_accessible_ref_selection (AtkSelection *selection, gint i)
+{
+	PanelAddtoCanvasPrivate *priv;
+	PanelAddtoCanvas *canvas;
+	GtkWidget *widget;
+
+	widget = GTK_ACCESSIBLE (selection)->widget;
+
+	if (!widget)
+		return NULL;
+
+	canvas = PANEL_ADDTO_CANVAS (widget);
+	priv   = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+
+	if (priv->selected)
+		return atk_object_ref_accessible_child (gtk_widget_get_accessible (widget),
+							((EntryInfo *)priv->selected->user_data)->index);
+	return NULL;
+}
+
+static gint
+panel_addto_canvas_accessible_get_selection_count (AtkSelection *selection)
+{
+	PanelAddtoCanvasPrivate *priv;
+	PanelAddtoCanvas *canvas;
+	GtkWidget *widget;
+
+	widget = GTK_ACCESSIBLE (selection)->widget;
+
+	if (!widget)
+		return 0;
+
+	canvas = PANEL_ADDTO_CANVAS (widget);
+	priv   = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+
+	return (priv->selected) ? 1 : 0;
+}
+
+static gboolean
+panel_addto_canvas_accessible_is_child_selected (AtkSelection *selection, gint i)
+{
+	PanelAddtoCanvasPrivate *priv;
+	PanelAddtoCanvas *canvas;
+	GtkWidget *widget;
+
+	widget = GTK_ACCESSIBLE (selection)->widget;
+
+	if (!widget)
+		return FALSE;
+
+	canvas = PANEL_ADDTO_CANVAS (widget);
+	priv   = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+
+	return (priv->selected == panel_addto_canvas_accessible_get_entry (canvas, i));
+}
+
+static gboolean
+panel_addto_canvas_accessible_remove_selection (AtkSelection *selection, gint i)
+{
+	/* There can be only one item selected */
+	return panel_addto_canvas_accessible_clear_selection (selection);
+}
+
+static gboolean
+panel_addto_canvas_accessible_select_all_selection (AtkSelection *selection)
+{
+	/* This can't happen */
+	return FALSE;
+}
+
+static void
+panel_addto_canvas_accessible_selection_interface_init (AtkSelectionIface *iface)
+{
+	iface->add_selection = panel_addto_canvas_accessible_add_selection;
+	iface->clear_selection = panel_addto_canvas_accessible_clear_selection;
+	iface->ref_selection = panel_addto_canvas_accessible_ref_selection;
+	iface->get_selection_count = panel_addto_canvas_accessible_get_selection_count;
+	iface->is_child_selected = panel_addto_canvas_accessible_is_child_selected;
+	iface->remove_selection = panel_addto_canvas_accessible_remove_selection;
+	iface->select_all_selection = panel_addto_canvas_accessible_select_all_selection;
+}
+
+static AtkObject*
+panel_addto_canvas_accessible_ref_accessible_at_point (AtkComponent *component,
+						   gint          x,
+						   gint          y,
+						   AtkCoordType  coord_type)
+{
+	GSList                  *l, *m;
+	GtkWidget               *widget;
+	PanelAddtoCanvasPrivate *priv;
+	PanelAddtoCanvas        *canvas;
+	PanelAddtoCategory      *current_category;
+	EntryInfo               *entry;
+	gint x_pos, y_pos, x_w, y_w;
+
+	widget = GTK_ACCESSIBLE (component)->widget;
+
+	if (widget == NULL)
+		return NULL;
+
+	canvas = PANEL_ADDTO_CANVAS (widget);
+	priv   = PANEL_ADDTO_CANVAS_GET_PRIVATE (canvas);
+
+	atk_component_get_extents (component, &x_pos, &y_pos, NULL, NULL, coord_type);
+	x_w = x - x_pos;
+	y_w = y - y_pos;
+
+	for (l = priv->info->categories; l; l = l->next) {
+		current_category = l->data;
+		for (m = current_category->entries; m; m = m->next) {
+			entry = (EntryInfo *) m->data; 
+			
+			if (x_w > entry->cover->x1 &&
+			    x_w < entry->cover->x2 &&
+			    y_w > entry->cover->y1 &&
+			    y_w < entry->cover->y2)
+				return panel_addto_canvas_accessible_ref_child (ATK_OBJECT (component), entry->index);
+		}
+	}
+
+	return NULL;
+}
+
+static void
+atk_component_interface_init (AtkComponentIface *iface)
+{
+	iface->ref_accessible_at_point = panel_addto_canvas_accessible_ref_accessible_at_point;
+}
+
+static GType
+panel_addto_canvas_accessible_get_type (void)
+{
+	static GType type = 0;
+	AtkObjectFactory *factory;
+	GType derived_type;
+	GTypeQuery query;
+	GType derived_atk_type;
+
+	if (type == 0) {
+		static GTypeInfo info = {
+			0, /* class size */
+			(GBaseInitFunc) NULL, /* base init */
+			(GBaseFinalizeFunc) NULL, /* base finalize */
+			(GClassInitFunc) panel_addto_canvas_accessible_class_init,
+			(GClassFinalizeFunc) NULL, /* class finalize */
+			NULL, /* class data */
+			0, /* instance size */
+			0, /* nb preallocs */
+			(GInstanceInitFunc) NULL, /* instance init */
+			NULL /* value table */
+		};
+
+		static const GInterfaceInfo  atk_component_info = {
+			(GInterfaceInitFunc) atk_component_interface_init,
+			(GInterfaceFinalizeFunc) NULL,
+			NULL
+		};
+
+		static const GInterfaceInfo atk_selection_info = {
+			(GInterfaceInitFunc) panel_addto_canvas_accessible_selection_interface_init,
+			(GInterfaceFinalizeFunc) NULL,
+			NULL
+		};
+
+		derived_type = g_type_parent (PANEL_ADDTO_TYPE_CANVAS);
+		factory = atk_registry_get_factory (atk_get_default_registry (),
+						    derived_type);
+
+		derived_atk_type = atk_object_factory_get_accessible_type (factory);
+		g_type_query (derived_atk_type, &query);
+
+		info.class_size = query.class_size;
+		info.instance_size = query.instance_size;
+
+		type = g_type_register_static (derived_atk_type,
+					       "PanelAddtoCanvasAccessible",
+					       &info, 0);
+
+		g_type_add_interface_static (type,
+					     ATK_TYPE_COMPONENT,
+					     &atk_component_info);
+		g_type_add_interface_static (type,
+					     ATK_TYPE_SELECTION,
+					     &atk_selection_info);
+	}
+
+	return type;
+}
+
+static AtkObject*
+panel_addto_canvas_accessible_new (GObject *object)
+{
+	AtkObject *accessible;
+
+	accessible = g_object_new (panel_addto_canvas_accessible_get_type (), NULL);
+	atk_object_initialize (accessible, object);
+
+	return accessible;
+}
+
+static AtkObject*
+panel_addto_canvas_accessible_factory_create_accessible (GObject *object)
+{
+	return panel_addto_canvas_accessible_new (object);
+}
+
+static void
+panel_addto_canvas_accessible_factory_class_init (AtkObjectFactoryClass *class)
+{
+	class->create_accessible   = panel_addto_canvas_accessible_factory_create_accessible;
+	class->get_accessible_type = panel_addto_canvas_accessible_get_type;
+}
+
+static GType
+panel_addto_canvas_accessible_factory_get_type (void)
+{
+	static GType type = 0;
+
+	if (type == 0) {
+		static const GTypeInfo info = {
+			sizeof (AtkObjectFactoryClass),
+			NULL,           /* base_init */
+			NULL,           /* base_finalize */
+			(GClassInitFunc) panel_addto_canvas_accessible_factory_class_init,
+			NULL,           /* class_finalize */
+			NULL,           /* class_data */
+			sizeof (AtkObjectFactory),
+			0,             /* n_preallocs */
+			NULL, NULL
+		};
+
+		type = g_type_register_static (ATK_TYPE_OBJECT_FACTORY,
+					       "PanelAddtoCanvasAccessibleFactory",
+					       &info, 0);
+	}
+
+	return type;
+}
+
+static AtkObject*
+panel_addto_canvas_get_accessible (GtkWidget *widget)
+{
+	static gboolean already_here = FALSE;
+
+	if (!already_here) {
+		AtkObjectFactory *factory;
+		AtkRegistry *registry;
+		GType derived_type;
+		GType derived_atk_type;
+
+		already_here = TRUE;
+
+		derived_type = g_type_parent (PANEL_ADDTO_TYPE_CANVAS);
+
+		registry = atk_get_default_registry ();
+		factory  = atk_registry_get_factory (registry, derived_type);
+
+		derived_atk_type = atk_object_factory_get_accessible_type (factory);
+
+		if (g_type_is_a (derived_atk_type, GTK_TYPE_ACCESSIBLE)) {
+			atk_registry_set_factory_type (registry,
+						       PANEL_ADDTO_TYPE_CANVAS,
+						       panel_addto_canvas_accessible_factory_get_type ());
+		}
+	}
+
+	return (* GTK_WIDGET_CLASS (panel_addto_canvas_parent_class)->get_accessible) (widget);
+}
diff -Nur gnome-panel-2.16.1/panel-addto-canvas.h gnome-panel-2.16.1.new/panel-addto-canvas.h
--- gnome-panel-2.16.1/panel-addto-canvas.h	1970-01-01 01:00:00.000000000 +0100
+++ gnome-panel-2.16.1.new/panel-addto-canvas.h	2006-10-03 01:10:39.000000000 +0200
@@ -0,0 +1,88 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+/* Copyright (C) 2005 Carlos Garnacho
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Authors: Jody Goldberg          <jody@gnome.org>
+ *          Carlos Garnacho Parro  <carlosg@gnome.org>
+ *          Manu Cornet            <manu@manucornet.net>
+ */
+
+#ifndef PANEL_ADDTO_CANVAS_H
+#define PANEL_ADDTO_CANVAS_H
+
+#include <libgnomecanvas/gnome-canvas.h>
+#include <gnome.h>
+#include "panel-addto.h"
+
+G_BEGIN_DECLS
+
+#define PANEL_ADDTO_TYPE_CANVAS         (panel_addto_canvas_get_type ())
+#define PANEL_ADDTO_CANVAS(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), PANEL_ADDTO_TYPE_CANVAS, PanelAddtoCanvas))
+#define PANEL_ADDTO_CANVAS_CLASS(c)     (G_TYPE_CHECK_CLASS_CAST    ((c), PANEL_ADDTO_TYPE_CANVAS, PanelAddtoCanvasClass))
+#define PANEL_ADDTO_IS_CANVAS(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), PANEL_ADDTO_TYPE_CANVAS))
+#define PANEL_ADDTO_IS_CANVAS_CLASS(c)  (G_TYPE_CHECK_CLASS_TYPE    ((c), PANEL_ADDTO_TYPE_CANVAS))
+#define PANEL_ADDTO_CANVAS_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS  ((o), PANEL_ADDTO_TYPE_CANVAS, PanelAddtoCanvasClass))
+
+typedef struct _PanelAddtoCanvas      PanelAddtoCanvas;
+typedef struct _PanelAddtoCanvasClass PanelAddtoCanvasClass;
+
+struct _PanelAddtoCanvas {
+	GnomeCanvas parent;
+};
+
+struct _PanelAddtoCanvasClass {
+	GnomeCanvasClass parent_class;
+
+	void (*changed) (PanelAddtoCanvas *canvas, gchar *str);
+};
+
+typedef struct _PanelAddtoCanvasPrivate PanelAddtoCanvasPrivate;
+
+struct _PanelAddtoCanvasPrivate {
+	GnomeCanvasItem *under_cover;
+	double height;
+	double width;
+
+	double min_height;
+	double max_width;
+	PanelAddtoInformation *info;
+	PanelAddtoEntry *selected;
+
+	gboolean rtl;
+	gint items_per_row;
+	gint selected_row;
+
+	gchar *search_text;
+
+	/* calculated sizes
+	   for the elements */
+	gdouble max_item_width;
+	gdouble max_item_height;
+	gdouble max_icon_height;
+
+	/* accessibility stuff */
+	GHashTable *accessible_children;
+};
+
+GType panel_addto_canvas_get_type (void);
+void activate_entry (PanelAddtoEntry *entry);
+void panel_addto_relayout_for_search (GtkWidget *search_entry, PanelAddtoDialog *dialog);
+void panel_addto_activate_from_searchbar (GtkWidget *search_entry, PanelAddtoDialog *dialog);
+GtkWidget* panel_addto_canvas_new (PanelAddtoInformation *info);
+
+G_END_DECLS
+
+#endif /* PANEL_ADDTO_CANVAS_H */
diff -Nur gnome-panel-2.16.1/panel-addto-event-box.c gnome-panel-2.16.1.new/panel-addto-event-box.c
--- gnome-panel-2.16.1/panel-addto-event-box.c	1970-01-01 01:00:00.000000000 +0100
+++ gnome-panel-2.16.1.new/panel-addto-event-box.c	2006-10-03 01:10:39.000000000 +0200
@@ -0,0 +1,99 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+/*
+ * Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002 Free Software Foundation
+ * All rights reserved.
+ *
+ * This file is part of the Gnome Library.
+ *
+ * The Gnome Library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Gnome Library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with the Gnome Library; see the file COPYING.LIB.  If not,
+ * write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+/*
+  @NOTATION@
+ */
+/* Event box item type for GnomeCanvas widget
+ *
+ * GnomeCanvas is basically a port of the Tk toolkit's most excellent canvas widget.  Tk is
+ * copyrighted by the Regents of the University of California, Sun Microsystems, and other parties.
+ *
+ *
+ * Author: Chris Lahey <clahey@ximian.com>
+ */
+
+#include <config.h>
+
+#include "panel-addto-event-box.h"
+
+#define noVERBOSE
+
+static GnomeCanvasItemClass *parent_class;
+
+static double
+panel_addto_event_box_point (GnomeCanvasItem *item, double x, double y, int cx, int cy,
+			     GnomeCanvasItem **actual_item)
+{
+	double x1, x2, y1, y2;
+	g_object_get (item,
+		      "x1", &x1,
+		      "x2", &x2,
+		      "y1", &y1,
+		      "y2", &y2,
+		      NULL);
+	if (x <= x2 && x >= x1 &&
+	    y <= y2 && y >= y1) {
+		*actual_item = item;
+		
+		return 0.0;
+	}
+	return 1e12;
+}
+
+static void
+panel_addto_event_box_class_init (PanelAddtoEventBoxClass *class)
+{
+	GnomeCanvasItemClass *item_class;
+
+	item_class = (GnomeCanvasItemClass *) class;
+
+	parent_class = g_type_class_peek_parent (class);
+
+	item_class->point = panel_addto_event_box_point;
+}
+
+GType
+panel_addto_event_box_get_type (void)
+{
+	static GType type;
+
+	if (!type) {
+		static const GTypeInfo object_info = {
+			sizeof (PanelAddtoEventBoxClass),
+			(GBaseInitFunc) NULL,
+			(GBaseFinalizeFunc) NULL,
+			(GClassInitFunc) panel_addto_event_box_class_init,
+			(GClassFinalizeFunc) NULL,
+			NULL,			/* class_data */
+			sizeof (PanelAddtoEventBox),
+			0,			/* n_preallocs */
+			(GInstanceInitFunc) NULL,
+			NULL			/* value_table */
+		};
+
+		type = g_type_register_static (GNOME_TYPE_CANVAS_RECT, "PanelAddtoEventBox",
+					       &object_info, 0);
+	}
+
+	return type;
+}
diff -Nur gnome-panel-2.16.1/panel-addto-event-box.h gnome-panel-2.16.1.new/panel-addto-event-box.h
--- gnome-panel-2.16.1/panel-addto-event-box.h	1970-01-01 01:00:00.000000000 +0100
+++ gnome-panel-2.16.1.new/panel-addto-event-box.h	2006-10-03 01:10:39.000000000 +0200
@@ -0,0 +1,75 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+/*
+ * Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002 Free Software Foundation
+ * All rights reserved.
+ *
+ * This file is part of the Gnome Library.
+ *
+ * The Gnome Library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The Gnome Library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with the Gnome Library; see the file COPYING.LIB.  If not,
+ * write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+/*
+  @NOTATION@
+ */
+/* Event Box item type for GnomeCanvas widget
+ *
+ * GnomeCanvas is basically a port of the Tk toolkit's most excellent canvas widget.  Tk is
+ * copyrighted by the Regents of the University of California, Sun Microsystems, and other parties.
+ *
+ *
+ * Author: Chris Lahey <clahey@ximian.com>
+ */
+
+#ifndef PANEL_ADDTO_EVENT_BOX_H
+#define PANEL_ADDTO_EVENT_BOX_H
+
+
+#include <libgnomecanvas/gnome-canvas.h>
+
+#include <libgnomecanvas/gnome-canvas-rect-ellipse.h>
+
+G_BEGIN_DECLS
+
+/* Event Box item.  No configurable or queryable arguments are available (use those in
+ * GnomeCanvasRE).
+ */
+
+
+#define PANEL_ADDTO_TYPE_EVENT_BOX            (panel_addto_event_box_get_type ())
+#define PANEL_ADDTO_EVENT_BOX(obj)            (GTK_CHECK_CAST ((obj), PANEL_ADDTO_TYPE_EVENT_BOX, PanelAddtoEventBox))
+#define PANEL_ADDTO_EVENT_BOX_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), PANEL_ADDTO_TYPE_EVENT_BOX, PanelAddtoEventBoxClass))
+#define PANEL_ADDTO_IS_EVENT_BOX(obj)         (GTK_CHECK_TYPE ((obj), PANEL_ADDTO_TYPE_EVENT_BOX))
+#define PANEL_ADDTO_IS_EVENT_BOX_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), PANEL_ADDTO_TYPE_EVENT_BOX))
+#define PANEL_ADDTO_EVENT_BOX_GET_CLASS(obj)  (GTK_CHECK_GET_CLASS ((obj), PANEL_ADDTO_TYPE_EVENT_BOX, PanelAddtoEventBoxClass))
+
+
+typedef struct _PanelAddtoEventBox      PanelAddtoEventBox;
+typedef struct _PanelAddtoEventBoxClass PanelAddtoEventBoxClass;
+
+struct _PanelAddtoEventBox {
+	GnomeCanvasRect item;
+};
+
+struct _PanelAddtoEventBoxClass {
+	GnomeCanvasRectClass parent_class;
+};
+
+
+/* Standard Gtk function */
+GType panel_addto_event_box_get_type (void) G_GNUC_CONST;
+
+G_END_DECLS
+
+#endif
diff -Nur gnome-panel-2.16.1/panel-addto-rounded-rect.c gnome-panel-2.16.1.new/panel-addto-rounded-rect.c
--- gnome-panel-2.16.1/panel-addto-rounded-rect.c	1970-01-01 01:00:00.000000000 +0100
+++ gnome-panel-2.16.1.new/panel-addto-rounded-rect.c	2006-10-03 01:10:39.000000000 +0200
@@ -0,0 +1,103 @@
+/* vim: set sw=8: -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+/*
+ * panel-addto-rounded-rect.c: A rectangle with rounded corners
+ *
+ * Copyright (C) 2004 Novell Inc
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of version 2 of the GNU General Public
+ * License as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+ * USA
+ */
+
+#include <config.h>
+#include "panel-addto-rounded-rect.h"
+#include "panel-addto-rounded-rect-pixbuf.h"
+#include <glib-object.h>
+#include <math.h>
+
+struct _PanelAddtoRoundedRect {
+	GnomeCanvasRect base;
+};
+typedef GnomeCanvasRectClass PanelAddtoRoundedRectClass;
+
+#define GNOMECC_ROUNDED_RECT_CLASS(k)	 (G_TYPE_CHECK_CLASS_CAST ((k), GNOMECC_TYPE_ROUNDED_RECT, PanelAddtoRoundedRectClass))
+#define GNOMECC_IS_ROUNDED_RECT_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), GNOMECC_TYPE_ROUNDED_RECT))
+
+G_DEFINE_TYPE (PanelAddtoRoundedRect, panel_addto_rounded_rect, GNOME_TYPE_CANVAS_RECT);
+
+/*************************************************************************
+ * Adapted from nautilus/libnautilus-private/nautilus-icon-canvas-item.c
+ */
+/* clear the corners of the selection pixbuf by copying the corners of the passed-in pixbuf */
+static void
+panel_addto_rounded_rect_draw (GnomeCanvasItem *item, GdkDrawable *drawable,
+			   int x, int y, int width, int height)
+{
+	static GdkPixbuf *corner_pixbuf = NULL;
+	GnomeCanvasRE const *re = GNOME_CANVAS_RE (item);
+	int dest_width, dest_height, src_width, src_height;
+	int dx, dy;
+	int corner_size = 5;
+	double affine[6];
+
+	GNOME_CANVAS_ITEM_CLASS (panel_addto_rounded_rect_parent_class)->draw (item, drawable, x, y, width, height);
+
+	if (corner_pixbuf == NULL)
+		corner_pixbuf = gdk_pixbuf_new_from_inline (-1,
+			panel_addto_rounded_rect_frame, FALSE, NULL);
+	src_width = gdk_pixbuf_get_width (corner_pixbuf);
+	src_height = gdk_pixbuf_get_height (corner_pixbuf);
+
+	gnome_canvas_item_i2c_affine (item, affine);
+
+	dest_width = fabs (re->x2 - re->x1);
+	dest_height = fabs (re->y2 - re->y1);
+	dx = affine[4] - x;
+	dy = affine[5] - y;
+	
+	/* draw top left corner */
+	gdk_draw_pixbuf (drawable, NULL, corner_pixbuf,
+			 0, 0,
+			 dx, dy,
+			 corner_size, corner_size,
+			 GDK_RGB_DITHER_NORMAL, 0, 0);
+	/* draw top right corner */
+	gdk_draw_pixbuf (drawable, NULL, corner_pixbuf,
+			 src_width - corner_size, 0,
+			 dx + dest_width - corner_size, dy,
+			 corner_size, corner_size,
+			 GDK_RGB_DITHER_NORMAL, 0, 0);
+	/* draw bottom left corner */
+	gdk_draw_pixbuf (drawable, NULL, corner_pixbuf,
+			 0, src_height - corner_size,
+			 dx, dy + dest_height - corner_size,
+			 corner_size, corner_size,
+			 GDK_RGB_DITHER_NORMAL, 0, 0);
+	/* draw bottom right corner */
+	gdk_draw_pixbuf (drawable, NULL, corner_pixbuf,
+			 src_width - corner_size, src_height - corner_size,
+			 dx + dest_width - corner_size, dy + dest_height - corner_size,
+			 corner_size, corner_size,
+			 GDK_RGB_DITHER_NORMAL, 0, 0);
+}
+
+static void
+panel_addto_rounded_rect_class_init (PanelAddtoRoundedRectClass *klass)
+{
+	GnomeCanvasItemClass	*item_klass = (GnomeCanvasItemClass *) klass;
+	item_klass->draw	= panel_addto_rounded_rect_draw;
+}
+static void
+panel_addto_rounded_rect_init (PanelAddtoRoundedRect *rr)
+{
+}
diff -Nur gnome-panel-2.16.1/panel-addto-rounded-rect.h gnome-panel-2.16.1.new/panel-addto-rounded-rect.h
--- gnome-panel-2.16.1/panel-addto-rounded-rect.h	1970-01-01 01:00:00.000000000 +0100
+++ gnome-panel-2.16.1.new/panel-addto-rounded-rect.h	2006-10-03 01:10:39.000000000 +0200
@@ -0,0 +1,39 @@
+/* vim: set sw=8: -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+/*
+ * gnomecc-rounded-rect.c: A rectangle with rounded corners
+ *
+ * Copyright (C) 2004 Novell Inc
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of version 2 of the GNU General Public
+ * License as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+ * USA
+ */
+#ifndef PANEL_ADDTO_ROUNDED_RECT_H
+#define PANEL_ADDTO_ROUNDED_RECT_H
+
+#include <libgnomecanvas/gnome-canvas.h>
+#include <libgnomecanvas/gnome-canvas-rect-ellipse.h>
+#include <glib-object.h>
+
+G_BEGIN_DECLS
+
+#define PANEL_ADDTO_TYPE_ROUNDED_RECT	(panel_addto_rounded_rect_get_type ())
+#define PANEL_ADDTO_ROUNDED_RECT(o)		(G_TYPE_CHECK_INSTANCE_CAST ((o), PANEL_ADDTO_TYPE_ROUNDED_RECT, PanelAddtoRoundedRect))
+#define PANEL_ADDTO_IS_ROUNDED_RECT(o)	(G_TYPE_CHECK_INSTANCE_TYPE ((o), PANEL_ADDTO_TYPE_ROUNDED_RECT))
+
+typedef struct _PanelAddtoRoundedRect PanelAddtoRoundedRect;
+GType panel_addto_rounded_rect_get_type (void);
+
+G_END_DECLS
+
+#endif /* PANEL_ADDTO_ROUNDED_RECT_H */
diff -Nur gnome-panel-2.16.1/panel-addto-rounded-rect-pixbuf.h gnome-panel-2.16.1.new/panel-addto-rounded-rect-pixbuf.h
--- gnome-panel-2.16.1/panel-addto-rounded-rect-pixbuf.h	1970-01-01 01:00:00.000000000 +0100
+++ gnome-panel-2.16.1.new/panel-addto-rounded-rect-pixbuf.h	2006-10-03 01:10:39.000000000 +0200
@@ -0,0 +1,319 @@
+/* GdkPixbuf RGBA C-Source image dump */
+
+#ifdef __SUNPRO_C
+#pragma align 4 (panel_addto_rounded_rect_frame)
+#endif
+#ifdef __GNUC__
+static const guint8 panel_addto_rounded_rect_frame[] __attribute__ ((__aligned__ (4))) = 
+#else
+static const guint8 panel_addto_rounded_rect_frame[] = 
+#endif
+{ ""
+  /* Pixbuf magic (0x47646b50) */
+  "GdkP"
+  /* length: header (24) + pixel_data (5848) */
+  "\0\0\26\360"
+  /* pixdata_type (0x1010002) */
+  "\1\1\0\2"
+  /* rowstride (344) */
+  "\0\0\1X"
+  /* width (86) */
+  "\0\0\0V"
+  /* height (17) */
+  "\0\0\0\21"
+  /* pixel_data: */
+  "\377\377\377\377\377\377\377\377\377\377\377\303\377\377\377q\377\377"
+  "\377/\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377/\377\377\377q\377\377\377\303\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377\242\377\377\377"
+  "(\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377(\377\377\377\242\377\377\377\377\377\377\377\303\377\377"
+  "\377(\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377(\377\377\377\303\377\377"
+  "\377q\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377q\377\377\377/\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377/\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377/\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377/\377\377"
+  "\377q\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377q\377\377\377\303\377\377\377(\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377(\377\377\377\303\377\377\377\377\377\377\377\242\377\377\377(\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377(\377\377\377\242\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\303\377\377\377q\377\377\377/\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377/\377\377\377q\377\377\377\303\377\377\377\377\377\377\377\377"};
+
+
